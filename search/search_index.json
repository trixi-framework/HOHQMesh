{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"HOHQMesh","text":"<p>HOHQMesh, the High Order Hex-Quad Mesher, is an open-source mesh generator that automatically creates quadrilateral/hexahedral meshes with high-order boundary information. To get an impression of what kind of meshes HOHQMesh can generate, please see the gallery.</p>"},{"location":"#what-you-can-do-with-hohqmesh","title":"What you can do with HOHQMesh","text":"<p>To use HOHQMesh to generate all-quadrilateral meshes with arbitrary order boundary elements you use a control file to</p> <ul> <li> <p>Define a <code>MODEL</code> consisting of</p> <ul> <li>An optional closed outer boundary curve made up of one or more connected curved segments defined by primitives like straight line segments, circular arcs, elliptic arcs, splines, or equations</li> <li>Zero or more closed inner boundary curves defined in the same way</li> <li>Zero or more internal boundary curves that define boundaries for multiple material applications</li> <li>An optional bottom topography defined either in functional form or from a file to use to refine a 2D mesh around bottom features. (For example for shallow water equation computations.)</li> </ul> </li> <li> <p>Tell it how to mesh the model with a <code>CONTROL_INPUT</code> section by</p> </li> <li>Setting run parameters that specify where to write the results, specify the mesh and plot file formats and set the polynomial order of the boundary curves</li> <li>Setting a background grid size to specify the largest element size desired</li> <li>Setting how the mesh should be smoothed</li> <li>Defining optional refinement regions to allow manual refinement of the mesh to emphasize specific regions not indicated by the boundary curves or topography.</li> </ul> <p>HOHQMesh will automatically generate a mesh with curved elements sized according to the geometry, like the curvature of the boundary curves and bottom topography, and the distance between boundary curves. It will generate a mesh that is symmetric about a symmetry line if segments of the outer boundary are defined as symmetry boundaries.</p> <p>Additionally, you can generate an all hexahedral mesh from the two-dimensional mesh by extruding a quadrilateral mesh by</p> <ul> <li>Simple extrusion along a coordinate direction</li> <li>Simple rotation about an axis</li> <li>Sweeping a quadrilateral mesh along a curve and optionally scaling the width along the way</li> </ul> <p>One can have the bottom of a hexahedral mesh follow a prescribed topography defined in functional form or from data. A 3D mesh can also be sized according to the curvature of the bottom topography.</p>"},{"location":"#news","title":"News","text":"<p>News about HOHQMesh can be found here.</p>"},{"location":"#getting-started","title":"Getting started","text":"<p>HOHQMesh can be used via HOHQMesh.jl, a Julia package that provides an interface to HOHQMesh and that supplies precompiled executables for Linux, macOS, Windows, and FreeBSD. If you would like to use HOHQMesh directly from the command line, please continue reading the next sections for instructions on how to obtain the sources and compile HOHQMesh yourself.</p>"},{"location":"#prerequisites","title":"Prerequisites","text":"<p>To build and install HOHQMesh, you need the following tools:</p> <ul> <li>A Fortran compiler (we recommend GFortran)</li> <li>GNU Make</li> <li>CMake (optional; only for CMake-based builds)</li> </ul> <p>Building on Linux and macOS should be straightforward, building on Windows requires MSYS2.</p>"},{"location":"#install-with-spack","title":"Install with Spack","text":"<p>You can install HOHQMesh using the Spack package manager. To install the HOHQMesh with Spack, <pre><code>git clone https://github.com/spack/spack.git ~/spack\nsource ~/spack/share/spack/setup-env.sh\nspack install hohqmesh@main\n</code></pre> This will install HOHQMesh and all of its dependencies (including FTObjectLibrary) from source code. Once installed, HOHQMesh can be added to your environment using <pre><code>spack load hohqmesh\n</code></pre></p>"},{"location":"#obtaining-the-sources","title":"Obtaining the sources","text":"<p>You can download the latest HOHQMesh release from GitHub. Make sure to get the tarball named <code>HOHQMesh-vVERSION.tar.gz</code>, as it already contains the required sources for the FTObjectLibrary dependency, and unpack it with <code>tar xf HOHQMesh-vVERSION.tar.gz</code>. Alternatively, you can build HOHQMesh directly from the latest sources in the <code>main</code> branch. In this case, you need enter the clone directory and execute <pre><code>./Utilities/bootstrap\n</code></pre> before proceeding, which will download the <code>FTObjectLibrary</code> sources for you. This step is required only once.</p>"},{"location":"#building","title":"Building","text":"<p>There are two ways to build HOHQMesh from source: Using plain <code>make</code> or by using CMake. The <code>make</code>-based build is conceptually simpler but only works as an in-source build, thus populating your HOHQMesh root directory with build artifacts. The CMake-based build is slightly more involved but also allows you to do out-of-source builds.</p> <p>HOHQMesh is tested to run with the <code>gfortran</code> and <code>ifort</code> compilers. We recommend the <code>gfortran</code> compiler. Our experience on the test suite is that it runs about 50% slower with the <code>ifort</code> compiler.</p>"},{"location":"#using-plain-make","title":"Using plain <code>make</code>","text":"<p>Enter the HOHQMesh directory and execute <pre><code>make\n</code></pre> This will build HOHQMesh using the <code>gfortran</code> compiler by default. The compiler choice can be overridden by passing <code>FC=&lt;pathToCompiler&gt;</code> to <code>make</code>. You can further pass the <code>-jN</code> option to <code>make</code> (with <code>N</code> being a non-negative integer), which will use <code>N</code> parallel processes.</p> <p>For example, to build HOHQMesh specifically with the Fortran compiler <code>gfortran-10</code> and with 4 parallel processes, execute <pre><code>make -j 4 FC=gfortran-10\n</code></pre></p>"},{"location":"#using-cmake","title":"Using CMake","text":"<p>For a CMake-based build, you first need to build the FTObjectLibrary, install it, and then build HOHQMesh itself. If you followed the steps for obtaining the sources above, all required files are already present.</p> <p>For convenience, we will assume that you are executing the following from within the HOHQMesh root directory. However, after modifying the paths appropriately, you can use these steps also from anywhere else:</p> <pre><code># Build and install FTObjectLibrary\nmkdir build-ftol &amp;&amp; cd build-ftol\ncmake ../Contrib/FTObjectLibrary/ -DCMAKE_INSTALL_PREFIX=../install\ncmake --build .\ncmake --install .\ncd ..\n\n# Build and install HOHQMesh\nmkdir build-hm &amp;&amp; cd build-hm\nCMAKE_PREFIX_PATH=../install cmake .. -DCMAKE_INSTALL_PREFIX=../install\ncmake --build .\ncmake --install .\ncd ..\n\n# Copy HOHQMesh executable to root directory\ncp install/bin/HOHQMesh .\n</code></pre> <p>The HOHQMesh executable can be moved around freely and does not rely on any other files in the install prefix or in the build directories (which can thus be deleted safely if so desired).</p> <p>By default, HOHQMesh (and FTObjectLibrary) will be built by the standard Fortran compiler configured for CMake.  The compiler choice can be overridden by setting the environment variable <code>FC=&lt;pathToCompiler&gt;</code> when invoking the configure step of CMake, e.g., <code>FC=gfortran-10 cmake ..</code>.</p>"},{"location":"#testing","title":"Testing","text":"<p>After building HOHQMesh, you can verify that everything works as expected by running the internal test suite. To execute the tests, type <pre><code>./HOHQMesh -test -path &lt;pathToBenchmarks&gt;\n</code></pre> where <code>&lt;pathToBenchmarks&gt;</code> is the path to the HOHQMesh directory. If you are inside the HOHQMesh directory, you can also omit the <code>-path</code> option, as it defaults to <code>.</code>.</p>"},{"location":"#generating-a-mesh","title":"Generating a mesh","text":"<p>To mesh a control file, type <pre><code>./HOHQMesh -f &lt;pathToControlFile&gt;\n</code></pre> where <code>-f</code> allows you to provide the path to the control file for which you want to create your mesh.</p> <p>For example, if you are inside the HOHQMesh root directory, you can run <pre><code>./HOHQMESH -f Examples/2D/GingerbreadMan/GingerbreadMan.control\n</code></pre> to generate a mesh for a gingerbread man geometry. This will produce three files, <pre><code>Examples/2D/GingerbreadMan/GingerbreadManMesh.mesh\nExamples/2D/GingerbreadMan/GingerbreadManPlot.tec\nExamples/2D/GingerbreadMan/GingerbreadManStats.txt\n</code></pre> where the <code>.mesh</code> file stores the actual mesh, the <code>.tec</code> file is a Tecplot-compatible visualization file, and the <code>.txt</code> file contains statistical information on the mesh quality.</p> <p>The Tecplot file can be visualized, e.g., using the open-source software ParaView, which has a built-in Tecplot reader. In the case of the gingerbread man, the resulting mesh should look like the example found in the online mesh gallery.</p>"},{"location":"#getting-help","title":"Getting help","text":"<p>To get a list of the command line options available in HOHQMesh, type <pre><code>./HOHQMesh -help\n</code></pre></p>"},{"location":"#documentation","title":"Documentation","text":"<p>Complete details on how to use HOHQMesh, including the preparation of input files, the different formats of the resulting mesh files, and visualization instructions, can be found in the online documentation.</p>"},{"location":"#referencing","title":"Referencing","text":"<p>If you use HOHQMesh in your own research, please cite the following article: <pre><code>@article{kopriva2024hohqmesh:joss,\n  title={{HOHQM}esh: An All Quadrilateral/Hexahedral Unstructured Mesh Generator for High Order Elements},\n  author={David A. Kopriva and Andrew R. Winters and Michael Schlottke-Lakemper\n          and Joseph A. Schoonover and Hendrik Ranocha},\n  year={2024},\n  journal={Journal of Open Source Software},\n  doi={10.21105/joss.07476},\n  volume = {9},\n  number = {104},\n  pages = {7476},\n  publisher = {The Open Journal}\n}\n</code></pre> In addition, you can also directly refer to this repository as <pre><code>@misc{kopriva2024hohqmesh:repo,\n  title={{HOHQM}esh: An All Quadrilateral/Hexahedral Unstructured Mesh Generator for High Order Elements},\n  author={Kopriva, David A and Winters, Andrew R and Schlottke-Lakemper, Michael\n          and Schoonover, Joseph A and Ranocha, Hendrik},\n  year={2024},\n  howpublished={\\url{https://github.com/trixi-framework/HOHQMesh}},\n  doi={10.5281/zenodo.13959058}\n}\n</code></pre></p>"},{"location":"#authors","title":"Authors","text":"<p>HOHQMesh was initiated by David A. Kopriva, who is also the principal developer. The full list of contributors can be found in the Authors section.</p>"},{"location":"#license-and-contributing","title":"License and contributing","text":"<p>HOHQMesh is licensed under the MIT license (see the License section).</p>"},{"location":"Gallery/","title":"Gallery","text":""},{"location":"Gallery/#a-hohqmesh-mesh-gallery","title":"A HOHQMesh Mesh Gallery","text":"<p>Please submit interesting contributions by uploading images to this repo and then updating the gallery page here!</p>"},{"location":"Gallery/#exterior-domains","title":"Exterior Domains","text":"Cylinder with a wake region (Andrew R. Winters)                  NACA0012 Airfoil (David A. Kopriva)        Three element Airfoil (Andrew R. Winters)         NACA6412 Airfoil (Andrew R. Winters)"},{"location":"Gallery/#coastlines","title":"Coastlines","text":"Indian Ocean (David A. Kopriva)                  Lake Superior (David A. Kopriva)                  East coast of the US (Joe Schoonover)                  Reyran river valley down to the Mediterranean Sea (Andrew R. Winters)"},{"location":"Gallery/#embedded","title":"Embedded","text":"Two embedded circles (David A. Kopriva)"},{"location":"Gallery/#topography","title":"Topography","text":"Mount St. Helens from above (Andrew R. Winters)                   Mount St. Helens, perspective view (Andrew R. Winters)                 East coast of the US with topography (Joe Schoonover)"},{"location":"Gallery/#just-for-fun","title":"Just for Fun","text":"Trixi logo (Andrew R. Winters)                  Jack o'Lantern  (Garrett Byrd)                 A ghost (Andrew R. Winters)                   A snow man (Andrew R. Winters)                 Gingerbread Man (David A. Kopriva)                   The Julia logo (Andrew R. Winters)"},{"location":"Gallery/#applications","title":"Applications","text":""},{"location":"News/","title":"ChangeLog","text":""},{"location":"News/#v155","title":"v1.5.5","text":"<ul> <li>Fixes a bug where material properties where not properly assigned when there was no outer boundary.</li> <li>Refinement for bottom topography uses the maximum principal curvature now.</li> <li>Documentation now explains that bottom topography refinement can be applied to two-dimensional meshes, too.</li> <li>A section on \"What you can do with HOHQMesh\" is added to the documentation.</li> <li>Information on how to cite the JOSS paper is added.</li> </ul>"},{"location":"TheISMMeshFileFormats/","title":"The HOHQMesh Mesh File Formats","text":"<p>HOHQMesh currently can write in four mesh file formats, ISM, ISM-v2, ISM-MM, and Abaqus. The ISM format was developed for the book \"Implementing Spectral Methods: Algorithms for Scientists and Engineers\" by David A. Kopriva and it supplies all the information needed to define high order curved elements of a spectral element mesh. Over time the format has evolved, with version ISM-v2 and ISM-MM added to include edge information and to handle multiple materials, respectively. The Abaqus mesh file format is common in the finite element community.</p>"},{"location":"TheISMMeshFileFormats/#ism","title":"ISM","text":"<p>The ISM mesh file format can define either Quad or Hex elements. Quad elements are defined as in ISM and shown in Fig. 27 below.</p> <p></p> <p> Fig. 27. The Quad element definition with corner nodes (circles) and sides (squares)  in their standard ordering.</p> <p>Hex elements are defined in a standard finite element topology.</p> <p></p> <p> Fig. 28. The Hex element definition with corner nodes (circles) and faces (squares), in their standard ordering.</p> <p>The ISM format includes (corner) nodes and element connectivity, with additional edge interpolation data to define high order boundary information. It can define either 2D Quad elements or 3D Hex elements; however, at the present time, there is no header to define the element type. Rather, that information is inferred from the number of nodes that define the corners.</p> <p>The top level view of the ISM file format is</p> <pre><code>Header\nList of Nodes\nList of Elements\n</code></pre> <p>The header consists of one line if the format is ISM, two lines for the others. The first line for all but the ISM format include the mesh format type. The other line of the header specifies the size of the mesh and the order of the polynomial that is used to define boundary curves.</p> <pre><code>#nodes  #elements  polynomialOrder\n</code></pre> <p>The list of nodes includes the (x,y,z) locations of the #nodes nodes in an ordered list</p> <pre><code>x1 y1 z1\nx2 y2 z2\n.\n.\n.\nxN yN zN\n</code></pre> <p>The list of elements is an ordered list of element blocks,</p> <pre><code>elementBlock1\nelementBlock2\n.\n.\n.\nelementBlockN\n</code></pre> <p>Each element block includes enough information to define a spectral element. Each block has</p> <pre><code>node IDs of the four/eight corners [+ material name, if ISM-MM]\nBoundary flags for the sides/faces (0 = straight/flat, 1 = curved)\nInterpolation values for the curved sides\nBoundary names for sides/faces\n</code></pre> <p>The node IDs are the IDs (as determined by their location in the node list) of the nodes defined in the Node block. Additional values used for Hex elements are shown in square brackets.</p> <pre><code>node1 node2 node3 node4 [node5 node6 node7 node8] [materialName]\n</code></pre> <p>The boundary flags are defined similarly,</p> <pre><code>bf1 bf2 bf3 bf4 [b5 b6]\n</code></pre> <p>where the boundary numbering is defined in Figs. 24 and 25 above.</p> <p>For each element boundary curve (or boundary face) for which the boundary flag = 1, a list of nodal values (x,y,z) is specified in order. The knots are assumed defined at the reversed Chebyshev Gauss-Lobatto points, \\(t_j = -\\cos(j \\pi /N)\\). For Quad elements the boundary curve blocks are the nodal values</p> <pre><code>x1,y1,z1\nx2,y2,z2\n.\n.\n.\nxN,yN,zN\n</code></pre> <p>For Hex elements, each block defines a surface patch, see below.</p> <p>The last line of the element block lists names of the physical boundaries associated with a side/face.</p> <pre><code>name1 name2 name3 name4 [name5 name6]\n</code></pre> <p>Interior (element-to-element) boundaries are denoted by --- (three dashes) to indicate no name.</p>"},{"location":"TheISMMeshFileFormats/#algorithm","title":"Algorithm","text":"<p>An algorithm for reading a quad mesh can therefore be written as</p> <pre><code>Read nNodes nElements pOrder\nFor n = 1 to nNodes\n    Read x[n] y[n] z[n]\nEnd\nFor n = 1 to nElements\n    Read (nodeID[k,n], k = 1,...,4), [materialName]\n    Read (bFlag[k,n], k = 1,...,4)\n    For k = 1 to 4\n        If bFlag(k) = 1 then\n            For i = 0 to pOrder\n                Read x[i,k,n] y[i,k,n] z[i,k,n]\n            End\n        End\n    End\n    Read (bName[k,n], k = 1,...,4)\nEnd\n</code></pre> <p>In this case, the index \\(i\\) corresponds to the first coordinate direction and \\(j\\) the second along the face.</p> <p>The Hex element block is similar, except that the faces are defined with nodes at the two-dimensional tensor-product of the Chebyshev Gauss-Lobatto points.</p> <pre><code>Read nNodes nElements pOrder\nFor n = 1 to nNodes\n    Read x[n] y[n] z[n]\nEnd\nFor n = 1 to nElements\n    Read (nodeID[k,n], k = 1,...,8), [materialName]\n    Read (bFlag[k,n], k = 1,...,6)\n    For k = 1 to 6\n        If bFlag(k) = 1 then\n            For j = 0 to pOrder\n                For i = 0 to pOrder\n                   Read x[i,j,k,n] y[i,j,k,n] z[i,j,k,n]\n                End\n            End\n        End\n    End\n    Read (bName[k,n], k = 1,...,6)\nEnd\n</code></pre> <p>If there are still questions, the source code for writing the mesh files can be found in <code>WriteISMMeshFile</code> in the file <code>MeshOutputMethods.f90</code> and <code>WriteISMHexMeshFile</code> in the file <code>Mesh3DOutputMethods.f90</code>.</p>"},{"location":"TheISMMeshFileFormats/#example","title":"Example","text":"<p>As a concrete example, we present the mesh file for a circular domain with five elements, shown in Fig. 8.15 of the book \"Implementing Spectral Methods\", reproduced below.</p> <p></p> <p> Fig. 29. The Quad mesh for a circle for whose mesh file is shown below.</p> <p>The mesh has five elements with eight corner nodes. The outer boundary (called \"outer\") is eighth order, so it has nine points defined for each curve.</p> <pre><code> 8 5 8                                     &lt;- #Nodes #Elements Polynomial Order\n0.7000000000000000 -0.7000000000000000 0.0 &lt;- Node 1 corner node location\n1.4142135623730951 -1.4142135623730949 0.0\n0.7000000000000000 0.7000000000000000 0.0\n1.4142135623730951 1.4142135623730949 0.0\n-0.7000000000000000 0.7000000000000000 0.0\n-1.4142135623730949 1.4142135623730951 0.0\n-1.4142135623730954 -1.4142135623730949 0.0\n-0.7000000000000000 -0.7000000000000000 0.0 &lt;- Node 8 corner node location\n1 2 4 3                                     &lt;- First element block, node IDs\n0 1 0 0                                     &lt;- Side 2 is curved, others are straight\n1.4142135623730951 -1.4142135623730949 0.0  &lt;- Start of interpolant nodes for side 2\n1.4961851763911174 -1.3271887273283636 0.0\n1.6994209839390670 -1.0544990845645972 0.0\n1.9103423681217324 -0.5921081291107658 0.0\n2.0000000000000000 0.0000000000000000 0.0\n1.9103423681217324 0.5921081291107657 0.0\n1.6994209839390670 1.0544990845645972 0.0\n1.4961851763911171 1.3271887273283638 0.0\n1.4142135623730951 1.4142135623730949 0.0 &lt;- End of interpolation nodes for side 2\n--- outer --- ---                         &lt;- Side 2 is named outer, others are interior sides\n5 3 4 6                                   &lt;- Start of Element 2 block\n0 0 1 0\n-1.4142135623730949 1.4142135623730951 0.0\n-1.3271887273283636 1.4961851763911174 0.0\n-1.0544990845645970 1.6994209839390670 0.0\n-0.5921081291107656 1.9103423681217324 0.0\n0.0000000000000000 2.0000000000000000 0.0\n0.5921081291107658 1.9103423681217324 0.0\n1.0544990845645974 1.6994209839390668 0.0\n1.3271887273283638 1.4961851763911169 0.0\n1.4142135623730951 1.4142135623730949 0.0\n--- outer --- ---\n7 8 5 6\n0 0 0 1\n-1.4142135623730954 -1.4142135623730949 0.0\n-1.4961851763911174 -1.3271887273283636 0.0\n-1.6994209839390670 -1.0544990845645970 0.0\n-1.9103423681217326 -0.5921081291107655 0.0\n-2.0000000000000000 0.0000000000000000 0.0\n-1.9103423681217324 0.5921081291107659 0.0\n-1.6994209839390668 1.0544990845645974 0.0\n-1.4961851763911169 1.3271887273283638 0.0\n-1.4142135623730949 1.4142135623730951 0.0\n--- --- --- outer\n7 2 1 8\n1 0 0 0\n-1.4142135623730954 -1.4142135623730949 0.0\n-1.3271887273283640 -1.4961851763911169 0.0\n-1.0544990845645983 -1.6994209839390662 0.0\n-0.5921081291107669 -1.9103423681217322 0.0\n0.0000000000000000 -2.0000000000000000 0.0\n0.5921081291107663 -1.9103423681217322 0.0\n1.0544990845645961 -1.6994209839390677 0.0\n1.3271887273283627 -1.4961851763911180 0.0\n1.4142135623730949 -1.4142135623730954 0.0\n8 1 3 5\n0 0 0 0                                 &lt;- Interior box, no curve values follow\n--- --- --- ---\n</code></pre>"},{"location":"TheISMMeshFileFormats/#additions-for-ism-v2-and-ism-mm","title":"Additions for ISM-v2 and ISM-MM","text":"<p>The ISM-v2 and ISM-MM formats adds edge information to the ISM mesh file.</p> <p>The first line of the mesh file will state that fact, that is, if the first line is ISM-V2 then it will have the edge information.</p> <p>Line 1:</p> <pre><code>ISM-V2\n</code></pre> <p>The second line now also includes the number of edges in the mesh as follows:</p> <pre><code>#nodes, #edges, #elements, polynomial order of boundary edges\n</code></pre> <p>The edges are read immediately after the nodes. For each edge the following are listed:</p> <pre><code>start node ID, end node ID, element ID on left, element ID on right, side of left element, side of right element\n</code></pre> <p>These are the quantities that are computed in Alg. 148 of \"Implementing Spectral Methods\". If the edge is a boundary edge, then the second side element will be ID = 0 and the side of that element will be 0. If the sides have indices that increase in opposite directions, then the last column in the data will be negative.</p>"},{"location":"TheISMMeshFileFormats/#abaqus-mesh-file-format","title":"ABAQUS mesh file format","text":"<p>The Abaqus mesh file format is common in the finite element community. The ABAQUS mesh file should use the <code>.inp</code> extension. The standard Abaqus format includes a list of node data and a list of element connectivity information. In this sense it is similar to the ISM format without high-order boundary information. The standard Abaqus format encodes a straight sided (linear) mesh.</p> <p>Herein, we describe an extended version to the ABAQUS format, divided into two parts. The first parts includes the standard Abaqus node and element lists. The second part encodes the high-order boundary information and naming information created by HOHQMesh. This second set of information is output in such a way that it will be ignored by standard ABAQUS file parsers, but the information is available if desired. For example, a <code>.inp</code> mesh file created by HOHQMesh can be parsed into Trixi.jl to create high-order curved AMR meshes.</p> <p>First, we describe the linear mesh skeleton encoded in the standard Abaqus format. For this example we use a quadrilateral mesh with 122 corner nodes and 103 elements:</p> <pre><code>*Heading\n File created by HOHQMesh\n*NODE\n1, x1, y1, z1\n2, x2, y2, z2\n.\n.\n.\n122, x122, y122, z122\n*ELEMENT, type=CPS4, ELSET=Surface1\n1, 1, 2, 9, 8\n2, 2, 3, 10, 9\n.\n.\n.\n103, 7, 122, 87, 8\n</code></pre> <p>Note that the first column in the node or element list is used for indexing purposes. The four other indices in each line of the <code>*ELEMENT</code> list are the corner IDs that dictate the element connectivity. These corner IDs are listed to guarantee right-handed element just as with the ISM format. The Abaqus element type <code>CPS4</code> corresponds to a quadrilateral element. For the three-dimensional variant of this mesh file output we use</p> <pre><code>*ELEMENT, type=C3D8, ELSET=Volume1\n</code></pre> <p>where <code>C3D8</code> corresponds to a hexahedron.</p> <p>The standard Abaqus file format can be used to create a straight-sided mesh. The high-order boundary information and curvature generated by HOHQMesh is output in the second portion of this mesh file. We demarcate between the two portions of the mesh file with the comment line</p> <pre><code>** ***** HOHQMesh boundary information ***** **\n</code></pre> <p>In the Abaqus format anything prefaced with <code>**</code> is treated as a comment and is ignored by an ABAQUS file parser. Therefore, all the HOHQMesh information output in the second portion of the mesh file is prefaced with <code>**</code> to act as an Abaqus comment. After the above comment line the mesh file gives the polynomial degree of the boundary curves in the mesh. Then, this mesh file format closely resembles the ISM format albeit slightly reordered. First, there is a list of the element connectivity, curved edge checks, and polynomial interpolant information after which comes the list of boundary names.</p> <p>The order of the boundary names is a final difference in the mesh format. The Abaqus format and libraries that use it (e.g. <code>p4est</code>) require the boundary labels in a particular order. In general, we can think of a quadrilateral element to have sides labeled</p> <pre><code>                      +y\n               -----------------\n               |               |\n               | ^ y           |\n            -x | |             | +x\n               | |             |\n               | ---&gt; x        |\n               -----------------\n                       -y\n</code></pre> <p>For this mesh file output the boundary labels are reordered to adopt the order convention of <code>-x +x -y +y</code>. For comparison, the default HOHQMesh ordering used by ISM or ISM-v2 gives the boundary labels in the order <code>-y +x +y -x</code>. Similarly, the boundary names are reordered for the 3D HOHQMesh output to adopt the convention <code>-x +x -y +y -z +z</code> compared to the ISM formatting of 3D boundary names which is <code>-y +y -z +x +z -x</code>.</p>"},{"location":"WorkflowTools/","title":"Workflow Tools","text":"<p>Two tools are available to help generate control files from which to generate a mesh with HOHQMesh.</p>"},{"location":"WorkflowTools/#hohqmeshjl","title":"HOHQMesh.jl","text":"<p>HOHQMesh.jl is a simple graphical front end to HOHQMesh that allows one to draw and edit the geometry, mesh and visualize in one package. It also includes binaries for the mesher so that it is not necessary to compile HOHQMesh oneself. Tutorials on how to use HOHQMesh.jl can be found here.</p>"},{"location":"WorkflowTools/#svg-to-hohqmesh","title":"svg-to-HOHQMesh","text":"<p>svg-to-HOHQMesh is a tool created by FluidNumerics that enables one to draw the geometry in a program like inkScape and then write a control file to be meshed. A demo is included on the gitHub site, and on YouTube. The pumpkin mesh in the HOHQMesh gallery was generated with svg-to-HOHQMesh.</p>"},{"location":"adding-a-new-test/","title":"Adding a New Test","text":"<p>When a new feature is added to HOHQMesh it is best practice to add a (small) corresponding test case control file that exercises these new routines. Adding a new test is straightforward with the following procedure:</p> <ol> <li>Create a new control file, e.g., <code>NewTestMesh.control</code> and save it in the folder <code>/Benchmarks/ControlFiles</code>. This    is the version of the control file that HOHQMesh will execute for testing.</li> <li>In this new control file add the keyword \"test file name\" with an appropriate file path and name corresponding to the test    to the RUN_PARAMETERS block of the control file. For example, in <code>NewTestMesh.control</code> <pre><code>test file name = /Benchmarks/BenchmarkData/NewTestMesh.txt\n</code></pre>    will indicate that the benchmark information should be written to the file <code>NewTestMesh.txt</code>.    The file path <code>/Benchmarks/BenchmarkData</code> is the expected path for the automated tests.</li> <li>Generate the benchmark information by adding the <code>-generateTest</code> flag, i.e.    <pre><code>./HOHQMesh -generateTest -f Benchmarks/ControlFiles/NewTestMesh.control\n</code></pre>    This will write the test benchmark file to the location requested in the previous step.</li> <li>Open the file <code>/Benchmarks/BenchmarkFiles.txt</code> and add the new control file path to the list of test cases, e.g.,    <pre><code>Benchmarks/ControlFiles/NewTestMesh.control\n</code></pre></li> </ol> <p>To execute the tests locally type <pre><code>./HOHQMesh -test -path &lt;pathToBenchmarks&gt;\n</code></pre> where <code>&lt;pathToBenchmarks&gt;</code> is the path to the HOHQMesh directory. If you are inside the HOHQMesh directory, you can also omit the <code>-path</code> option, as it defaults to <code>.</code>.</p>"},{"location":"appendix/","title":"Appendix","text":""},{"location":"appendix/#appendix-a-summary-of-boundary-curve-definitions","title":"Appendix A: Summary of Boundary Curve Definitions","text":"<p>Defining a parametric equation:</p> <pre><code>   \\begin{PARAMETRIC_EQUATION_CURVE}\n     name = &lt;name&gt;\n     xEqn = x(t) = &lt;x-equation&gt;\n     yEqn = y(t) = &lt;y-equation&gt;\n     zEqn = z(t) = 0.0\n \\end{PARAMETRIC_EQUATION_CURVE}\n</code></pre> <p>Defining a Spline:</p> <pre><code>\\begin{SPLINE_CURVE}\n   name = &lt;name&gt;\n   nKnots = # of nodes\n    \\begin{SPLINE_DATA}\n      t x y z\n      .\n      .\n      .\n    \\end{SPLINE_DATA}\n \\end{SPLINE_CURVE}\n</code></pre> <p>In one of the few cases where the order of keywords is important, the <code>nKnots</code> definition must precede the <code>\\begin{SPLINE_DATA}</code> block.</p> <p>Alternatively,</p> <pre><code>\\begin{SPLINE_CURVE}\n    name = &lt;name&gt;\n    file = &lt;pathToDataFile&gt;\n\\end{SPLINE_CURVE}\n</code></pre> <p>The data file will have the number of nodes as the first line, followed by the data, e.g.</p> <pre><code>    9\n    0.000000000000000 -3.50000000000000  3.50000000000000 0.0\n    3.846153846153846E-002 -3.20000000000000  5.00000000000 0.0\n    7.692307692307693E-002 -2.00000000000000  6.00000000000 0.0\n    0.769230769230769  0.000000000000000 -1.00000000000000 0.0\n    0.807692307692308 -1.00000000000000 -1.00000000000000 0.0\n    0.846153846153846 -2.00000000000000 -0.800000000000000 0.0\n    0.884615384615385 -2.50000000000000  0.000000000000000 0.0\n    0.923076923076923 -3.00000000000000  1.00000000000000 0.0\n    1.00000000000000 -3.50000000000000  3.50000000000000 0.0\n</code></pre> <p>Defining a Straight Line:</p> <pre><code>  \\begin{END_POINTS_LINE}\n       name   = &lt;name&gt;\n       xStart = [x,y,0]\n       xEnd   = [x,y,0]\n  \\end{END_POINTS_LINE}\n</code></pre> <p>Defining a Circular Arc:</p> <pre><code>  \\begin{CIRCULAR_ARC}\n       name      = &lt;name&gt;\n       units     = degrees/radians(Optional.Default:radians)\n       center    = [x,y,0.0]\n      radius     = r\n       start angle = Tstart\n       end angle   = Tend\n  \\end{CIRCULAR_ARC}\n</code></pre> <p>Defining an Elliptic Arc:</p> <pre><code>      \\begin{ELLIPTIC_ARC}\n           name    = &lt;name&gt;\n           center  = [x, y, 0.0]\n           xRadius = rX\n           yRadius = rY\n           start angle = Tstart\n           end angle   = Tend\n          units        = degrees/radians (Optional. Default:radians)\n          rotation     = &lt;angle&gt; (Optional. Default 0.0)\n      \\end{ELLIPTIC_ARC}\n</code></pre> <p>Chaining curves:</p> <pre><code>\\begin{CHAIN}\n    name = &lt;Chain Name&gt;\n    First curve definition\n    Second curve definition\n    ...\n    Last curve definition\n\\end{CHAIN}\ufffc\n</code></pre>"},{"location":"appendix/#appendix-b-summary-of-model-definition-blocks","title":"Appendix B: Summary of Model Definition Blocks","text":"<p>No inner boundaries:</p> <pre><code>   \\begin{MODEL}\n    \\begin{OUTER_BOUNDARY}\n        First curve definition\n        Second curve definition\n        ...\n        Last curve definition\n    \\end{OUTER_BOUNDARY}\n\\end{MODEL}\n</code></pre> <p>No outer boundaries:</p> <pre><code>   \\begin{MODEL}\n    \\begin{INNER_BOUNDARIES}\n        First chain definition\n        Second chain definition\n        ...\n        Last chain definition\n    \\end{INNER_BOUNDARIES}\n\\end{MODEL}\n</code></pre> <p>Both inner and outer boundaries:</p> <pre><code>   \\begin{MODEL}\n    \\begin{OUTER_BOUNDARY}\n        First curve definition\n        Second curve definition\n        ...\n        Last curve definition\n    \\end{OUTER_BOUNDARY}\n    \\begin{INNER_BOUNDARIES}\n        First chain definition\n        Second chain definition\n        ...\n        Last chain definition\n    \\end{INNER_BOUNDARIES}\n\\end{MODEL}\n</code></pre>"},{"location":"appendix/#appendix-c-summary-of-the-control-block","title":"Appendix C: Summary of the Control Block","text":"<p>The control block (required):</p> <pre><code>\\begin{CONTROL_INPUT}\n    ...\n\\end{CONTROL_INPUT}\n</code></pre> <p>The run parameters (required):</p> <pre><code>\\begin{RUN_PARAMETERS}\n  mesh file name   = &lt;pathToMeshFile&gt;\n  plot file name   = &lt;pathToPlotFile&gt;\n  stats file name  = &lt;pathToStatsFile&gt; **or** none\n  mesh file format = ISM **or** ISM-v2\n  polynomial order = Boundary polynomial order\n  plot file format = skeleton **or** sem\n\\end{RUN_PARAMETERS}\n</code></pre> <p>To specify the background grid (required):</p> <pre><code>\\begin{BACKGROUND_GRID}\n  background grid size = [x,y,0.0]\n\\end{BACKGROUND_GRID}\n</code></pre> <p>if there is an outer boundary curve in the model. If there is no outer boundary, just an implied box, then use</p> <pre><code>\\begin{BACKGROUND_GRID}\n   x0 = [xLeft, yBottom, 0.0]\n   dx = [dx, dy, 0.0]\n   N  = [Nx,nY,0]\n\\end{BACKGROUND_GRID}\n</code></pre> <p>Smoothing is recommended (highly!)</p> <pre><code>\\begin{SPRING_SMOOTHER}\n  smoothing            = ON **or** OFF\n  smoothing type       = LinearAndCrossbarSpring **or* LinearSpring\n  number of iterations = typically 20-30\n\\end{SPRING_SMOOTHER}\n</code></pre> <p>If manual local refinement is desired, include</p> <pre><code>\\begin{REFINEMENT_REGIONS}\n    ...\n\\END{REFINEMENT_REGIONS}\n</code></pre> <p>with blocks of the types</p> <pre><code>   \\begin{REFINEMENT_CENTER}\n      type = smooth **or** sharp\n      x0   = [xCenter,-yCenter,0.0]\n      h    = mesh size\n      w    = radial extent\n  \\end{REFINEMENT_CENTER}\n\n   \\begin{REFINEMENT_LINE}\n      type = smooth **or** sharp\n      x0   = [xStart,yStart,0.0]\n      x1   = [xEnd,yEnd,0.0]\n      h    = mesh size\n      w    = width of line\n   \\end{REFINEMENT_LINE}\n</code></pre> <p>To generate 3D meshes, add an extrusion algorithm, either</p> <pre><code>\\begin{SIMPLE_EXTRUSION}\n  direction          = 1 (=x), 2 (=y), 3 (=z)\n  height             = height of extrusion\n  subdivisions       = how many elements in the extrusion direction\n  start surface name = name of start surface\n  end surface name   = name of end surface\n\\end{SIMPLE_EXTRUSION}\n</code></pre> <p>or to sweep-rotate a 2D mesh,</p> <pre><code>\\begin{SIMPLE_ROTATION}\n  direction             = 1 (=x), 2 (=y), 3 (=z) = rotation axis\n  rotation angle factor =  fraction of pi\n  subdivisions          = number of elements in direction\n  start surface name    = name of start surface\n  end surface name      = name of end surface\n\\end{SIMPLE_ROTATION}\n</code></pre> <p>or to sweep along a curve,</p> <pre><code>\\begin{SWEEP_ALONG_CURVE}\n  algorithm                = Hanson (optional)\n  subdivisions per segment = Subdivisions for each curve in sweep curve chain\n  start surface name       = name of start surface\n  end surface name         = name of end surface\n\\end{SWEEP_ALONG_CURVE}\n</code></pre> <p>For the sweep-curve, add the curve to the model:</p> <pre><code>\\begin{SWEEP_CURVE}\n    ... Curve chain ...\n\\end{SWEEP_CURVE}\n</code></pre> <p>and if scaling along the sweep is desired, also add</p> <pre><code>  \\begin{SWEEP_SCALE_FACTOR}\n    ... chain of PARAMETRIC_EQUATIONs\n  \\end{SWEEP_SCALE_FACTOR}\n</code></pre> <p>to the model.</p> <p>If the SIMPLE_EXTRUSION is used, bottom topography can be optionally added to the model</p> <pre><code>\\begin{TOPOGRAPHY}\n    eqn = f(x,y) = some function of (x,y) as an equation\n    sizing = ON /OR/ OFF\n\\end{TOPOGRAPHY}\n</code></pre> <p>The <code>sizing</code> keyword is optional if no sizing along the topography is desired, or it can be turned <code>Off</code> for the same result.</p>"},{"location":"assumptions-and-algorithms/","title":"Assumptions and Algorithms","text":"<p>This is a collection of comments on some of the approximations and assumptions made in developing HOHQMesh. It is not exhaustive. It is also not in any particular order.</p> <ol> <li> <p>When checking to see whether or not two curves cross (when reading in the model), actual intersection is not tested. Rather, it looks to see if one or two points end up within the same bounding box. The assumption is that if the curves are that close together then the resolution is not good enough to generate a mesh anyway. See the subroutine CheckForBoundaryIntersections for details.</p> </li> <li> <p>The algorithm for parallel transport along a curve to sweep three dimensional meshes is only second order accurate. A 4th order scheme is published, but not implemented yet.</p> </li> <li> <p>In giving the background mesh size, the code assumes that the user knows this size is sufficiently small to be able to reasonably resolve the boundary curves. Choosing the background mesh h = 1 and the curves of size 0.1 cannot resolve a curve.</p> </li> <li> <p>A linear search is used in \"sizeFunctionMinimumOnBox\" to find the minimum of the size function. A note is included in the subroutine that that should be switched to a good minimization algorithm.</p> </li> <li> <p>Mesh sizes are determined (in part) by how close two curves are together (or how close a curve is to itself since the region they surround does not have to be convex). A bare minimum is three elements between since two will be deleted. The mesh size at any point along a curve is determined by a linear search through all points along the curve and all points along other curves. This is pretty bad, but meshing times so far have been sub-second so there has been little incentive to get picky.</p> </li> <li> <p>The sizer controls spread the region out using a Gaussian profile. The square root (for distance) and exponentials used are very expensive. Meshing times for meshes with sizer controls are significantly longer than those without. Since the actual shape of the regions is not important, consider using a quadratic polynomial approximation to a Gaussian instead to perhaps speed things up. In practice, of all the horrendous algorithms, the size controls seem to be the only ones that are costly.</p> </li> <li> <p>Sizing due to topography is chosen according to its principal curvatures. Background details on principle curvature are available in Section 3.4 of the online textbook \"Shape Interrogation for Computer Aided Design and Manufacturing\" by N. M. Patrikalakis, T. Maekawa, and W. Cho. The formulas to compute the principle curvatures for explicit surfaces are found in Section 3.5.1 of the same textbook. In HOHQMesh these formulas are approximated by second order finite differences.</p> </li> </ol>"},{"location":"authors/","title":"Authors","text":"<p>HOHQMesh's development is coordinated by David A. Kopriva, who is the principal developer and main contributor. In addition, there are contributors who have provided substantial additions or modifications. Together, these two groups form authors as mentioned in the the License section file.</p>"},{"location":"authors/#principal-developers","title":"Principal Developers","text":"<ul> <li>David A. Kopriva,   Florida State University, USA</li> </ul>"},{"location":"authors/#contributors","title":"Contributors","text":"<p>The following people contributed major additions or modifications to HOHQMesh and are listed in alphabetical order:</p> <ul> <li>David A. Kopriva</li> <li>Joseph Schoonover</li> <li>Andrew Winters</li> </ul>"},{"location":"building-the-documentation/","title":"Building the Documentation","text":"<p>To generate the HOHQMesh documentation, you need a reasonably recent version of Python 3 and the <code>mkdocs-material</code> package. The latter can be installed via <code>pip</code> using <pre><code>pip install mkdocs-material\n</code></pre> which will also install all relevant dependencies. Note that on some systems (e.g., Ubuntu 20.04), <code>mkdocs-material</code> requires a minimum version of the dependent <code>Jinja2</code> package that has a known bug. Please make sure that you have at least <code>Jinja2 2.11</code> installed by checking the output of <pre><code>pip show Jinja2\n</code></pre> If it is too old, you can upgrade Jinja2 by running <pre><code>pip install Jinja2 --upgrade\n</code></pre></p> <p>For local viewing, change to the directory where the <code>mkdocs.yml</code> file is located. Then execute <pre><code>./preparedocs\n</code></pre> to prepare some Markdown files that are located out of the main documentation directory <code>docs</code>. Then, you have two options:</p> <p>To view the documentation via the built-in webserver, execute <pre><code>mkdocs serve\n</code></pre> and follow the link printed to the terminal to open the documentation in your browser.</p> <p>To generate a static set of files on disk, run <pre><code>mkdocs build --no-directory-urls\n</code></pre> and open the file <code>site/index.html</code> in your browser.</p> <p>If, for some reason, you would like to download all images used in the documentation that are hosted on GitHub, you can automate this process by executing <pre><code>./download_github_images\n</code></pre> This will download the GitHub-hosted images and save them in the current working directory. Note that the script will only consider images that have been added to it manually.</p>"},{"location":"compiling-and-running-hohqmesh/","title":"Compiling and Running HOHQMesh","text":""},{"location":"compiling-and-running-hohqmesh/#quick-introduction","title":"Quick Introduction","text":"<p>HOHQMesh is currently being distributed on gitHub. In that repository is a makefile, plus source, documentation (which contains this document) and a directory of examples.</p> <p>HOHQMesh is written in fortran 2018. It is known to compile and run with <code>gfortran</code> on Mac/Linux/Windows and with <code>ifort</code> on Mac and Linux. At the time of this writing, HOHQMesh compiles, but does not run correctly, with the nFortran compiler from nvidia. Let us know if there are issues with other compilers, or more recent versions of those.</p> <p>The mesher has one dependency, FTObjectLibrary, which supplies the container classes and exception classes. It is also available on gitHub under a project of that name.</p> <p>The makefile is for gmake. Use it to compile the mesher.</p> <p>To build, edit the <code>Makefile</code> file as indicated in the header and move to ones favorite directory. Type <pre><code>make\n</code></pre> That will build HOHQMesh.</p>"},{"location":"compiling-and-running-hohqmesh/#getting-started","title":"Getting started","text":"<p>HOHQMesh can be used via HOHQMesh.jl, a Julia package that provides an interface to HOHQMesh and that supplies precompiled executables for Linux, macOS, Windows, and FreeBSD. If you would like to use HOHQMesh directly from the command line, please continue reading the next sections for instructions on how to obtain the sources and compile HOHQMesh yourself.</p>"},{"location":"compiling-and-running-hohqmesh/#install-with-spack","title":"Install with Spack","text":"<p>You can install HOHQMesh using the Spack package manager. To install the HOHQMesh with Spack, <pre><code>git clone https://github.com/spack/spack.git ~/spack\nsource ~/spack/share/spack/setup-env.sh\nspack install hohqmesh@main\n</code></pre> This will install HOHQMesh and all of its dependencies (including FTObjectLibrary) from source code. Once installed, HOHQMesh can be added to your environment using <pre><code>spack load hohqmesh\n</code></pre></p>"},{"location":"compiling-and-running-hohqmesh/#obtaining-the-sources","title":"Obtaining the sources","text":"<p>You can download the latest HOHQMesh release from GitHub. Make sure to get the tarball named <code>HOHQMesh-vVERSION.tar.gz</code>, as it already contains the required sources for the FTObjectLibrary dependency, and unpack it with <code>tar xf HOHQMesh-vVERSION.tar.gz</code>. Alternatively, you can build HOHQMesh directly from the latest sources in the <code>main</code> branch. In this case, you need enter the clone directory and execute <pre><code>./Utilities/bootstrap\n</code></pre> before proceeding, which will download the <code>FTObjectLibrary</code> sources for you. This step is required only once.</p>"},{"location":"compiling-and-running-hohqmesh/#building","title":"Building","text":"<p>Enter the HOHQMesh directory and execute <pre><code>make\n</code></pre> This will build HOHQMesh using the <code>gfortran</code> compiler by default. The compiler choice can be overridden by passing <code>FC=&lt;pathToCompiler&gt;</code> to <code>make</code>. You can further pass the <code>-jN</code> option to <code>make</code> (with <code>N</code> being a non-negative integer), which will use <code>N</code> parallel processes.</p> <p>For example, to build HOHQMesh specifically with the Fortran compiler <code>gfortran-10</code> and with 4 parallel processes, execute <pre><code>make -j 4 FC=gfortran-10\n</code></pre></p> <p>HOHQMesh is tested to run with the <code>gfortran</code> and <code>ifort</code> compilers. We recommend the <code>gfortran</code> compiler. Our experience on the test suite is that it runs about 50% slower with the <code>ifort</code> compiler.</p>"},{"location":"compiling-and-running-hohqmesh/#testing","title":"Testing","text":"<p>After building HOHQMesh, you can verify that everything works as expected by running the internal test suite. To execute the tests, type <pre><code>./HOHQMesh -test -path &lt;pathToBenchmarks&gt;\n</code></pre> where <code>&lt;pathToBenchmarks&gt;</code> is the path to the HOHQMesh directory. If you are inside the HOHQMesh directory, you can also omit the <code>-path</code> option, as it defaults to <code>.</code>.</p>"},{"location":"compiling-and-running-hohqmesh/#generating-a-mesh","title":"Generating a mesh","text":"<p>To mesh a control file, type <pre><code>./HOHQMesh -f &lt;pathToControlFile&gt;\n</code></pre> where <code>-f</code> allows you to provide the path to the control file for which you want to create your mesh.</p> <p>To mesh a control file, type</p> <pre><code>./HOHQMesh -f &lt;pathToControlFile&gt;\n</code></pre> <p>For example, to mesh the GingerbreadMan model in the Examples directory, type <pre><code>./HOHQMesh -f Examples/2D/GingerbreadMan/GingerbreadMan.control\n</code></pre></p> <p>The mesh and plot files will be created relative to the directory of the executable. For the moment, until things get really robust, diagnostic information can be printed as the program executes.</p> <p>Three more compiler flags are also defined:</p> <ul> <li>-version      Gives the version number of the code</li> <li>-help         Does nothing at the moment. Sorry. RTM.</li> <li>-verbose      Determines whether progress messages are printed or not.</li> </ul> <p>Use these as usual, e.g. <pre><code>./HOHQMesh -verbose -f Examples/2D/GingerbreadMan/GingerbreadMan.control\n</code></pre></p>"},{"location":"examples/","title":"Examples","text":"<p>HOHQMesh comes with 19 example control, mesh, and plot files for two-dimensional meshes found in the Examples/2D directory. These examples illustrate the use of the the control and model features, and the resulting meshes and plot files.</p> <p>Also included in the Examples directory is a control template: ControlTemplate.control, that can (like any of the examples) be modified at will.</p> Name Description Outer Inner Chain Parametric Eqn Spline Line Circular Arc Elliptic Arc Refinement Center Refinement Line AllFeatures A triangle with four holes :material-check: :material-check:4 :material-check: :material-check: :material-check: :material-check: :material-check: :material-check: :material-check: :material-check: BoneAndMarrow Two embedded domains :material-check: :material-close: :material-close: :material-check: :material-close: :material-close: :material-close: :material-close: :material-close: :material-close: BoxWithRefinement A square domain with a refined mesh :material-close: :material-close: :material-close: :material-close: :material-close: :material-close: :material-close: :material-close: :material-check: :material-check: CavityRamp A cavity domain with a sloping ramp on the exit side :material-check: :material-close: :material-check: :material-close: :material-close: :material-check: :material-close: :material-close: :material-close: :material-close: Circles3 Three circles enclosed by a large circle :material-check: :material-check:3 :material-close: :material-check: :material-close: :material-close: :material-close: :material-close: :material-close: :material-close: EastCoastUS A region of the US East Coast :material-check: :material-close: :material-check: :material-close: :material-check:(From file) :material-check: :material-close: :material-close: :material-close: :material-close: EllipseAndFourCircles Four circles enclosed by an ellipse :material-check: :material-check:4 :material-close: :material-check: :material-close: :material-close: :material-close: :material-close: :material-close: :material-close: GingerbreadMan Geometry with lots of holes :material-check: :material-check:6 :material-close: :material-check: :material-check: :material-close: :material-close: :material-close: :material-close: :material-close: Half Circle A half circle :material-check: :material-close: :material-close: :material-check: :material-close: :material-check: :material-close: :material-close: :material-close: :material-close: Indian Ocean Complex domain with islands and inlets :material-check: :material-check:3 :material-close: :material-close: :material-check: :material-close: :material-close: :material-close: :material-close: :material-close: KT3Element Three element Karman-Trefftz airfoil :material-close: :material-check:3 :material-close: :material-close: :material-check: :material-close: :material-close: :material-close: :material-close: :material-close: Lake Superior Complex domain with islands :material-check: :material-check:2 :material-close: :material-close: :material-check: :material-close: :material-close: :material-close: :material-close: :material-close: Malpasset Region of Malpasset Dam failure :material-check: :material-close: :material-close: :material-close: :material-check: :material-close: :material-close: :material-close: :material-close: :material-close: NACA0012 Standard Airfoil geometry :material-close: :material-check: :material-close: :material-check: :material-close: :material-close: :material-close: :material-close: :material-check: :material-close: PacMan A symmetric mesh :material-check: :material-close: :material-close: :material-check: :material-close: :material-check: :material-close: :material-close: :material-close: :material-close: Pill Oblong domain with interior circles :material-check: :material-check:3 :material-check: :material-close: :material-close: :material-close: :material-close: :material-close: :material-close: :material-close: RotatedEllipseWithSubregions Four circles, two half ellipses, and one quarter ellipse enclosed by an ellipse :material-check: :material-check:4 :material-close: :material-check: :material-close: :material-close: :material-close: :material-check: :material-close: :material-close: SplineGeometry Free form domain defined as a spline :material-check: :material-close: :material-close: :material-close: :material-check: :material-close: :material-close: :material-close: :material-close: :material-close: Square Generation of a Cartesian mesh with no model :material-close: :material-close: :material-close: :material-close: :material-close: :material-close: :material-close: :material-close: :material-close: :material-close: <p>There are also ten three dimensional examples that illustrate the different extrusion algorithms in the Examples/3D directory</p> Name Description Algorithm Topography BottomFromFile Extrusion of a rectangle SIMPLE_EXTRUSION :material-check:(From file) Box Extrusion of a square into a box. No Model SIMPLE_EXTRUSION :material-close: BoxRotated Rotation of a square about the x-axis. No Model SIMPLE_ROTATION :material-close: CavityRampExtruded Extrusion of the 2D CavityRamp SIMPLE_EXTRUSION :material-close: HalfCircleExtruded Extrusion of the 2D HalfCircle SIMPLE_EXTRUSION :material-close: HalfCircleRotated Rotation of the 2D half circle about the x-axis SIMPLE_ROTATION :material-close: MtStHelens Extrusion of a mountain topography in a rectangle SIMPLE_EXTRUSION :material-check:(From file) Pond Extrusion of a circle with topography and sizing SIMPLE_EXTRUSION :material-check: ScaledCylinder Sweeping of a circle with scale factor applied SWEEP_ALONG_CURVE :material-close: Snake Sweeping of a circle along multiple axes SWEEP_ALONG_CURVE :material-close:"},{"location":"how-hohqmesh-works/","title":"How HOHQMesh Works","text":""},{"location":"how-hohqmesh-works/#introduction","title":"Introduction","text":"<p>HOHQMesh is an automatic quad/hex mesh generator designed to be fully automatic. From the user's point of view, he/she creates a MODEL, which consists of (optionally) an outer boundary curve and any number of inner boundary curves. The user also includes CONTROL_INPUT to direct which files are created, the file formats, and three aspects of the mesh creation process: the background grid, which is the basic mesh size desired, the smoother, and manual refinement by way of REFINEMENT_CENTERs or REFINEMENT_LINES. The mesher then uses the model curves and control parameters to automatically refine near model features to generate a mesh.</p>"},{"location":"how-hohqmesh-works/#basic-2d-meshing-strategy","title":"Basic 2D Meshing strategy","text":"<p>The basic strategy for the 2D quadrilateral mesh generation is that devised by Robert Schneiders in \"Algorithms for Quadrilateral and Hexahedral Mesh Generation\". It appears to be unpublished but is available online.</p> <p>The basic 2D steps are:</p> <ol> <li>A uniform grid is laid down and a quadtree subdivision is performed until a size criterion is met. [MeshGeneratorMethods.f90/GenerateGridWithSizerAndType] </li> <li>The grid is made conforming by inserting templates for each possible non-conforming interface. There are 15 of these, plus rotations. [Templates.f90]</li> <li>Elements are created from the quads [MeshGeneratorMethods.f90/GenerateNodesAndElements]</li> <li>Exterior elements are marked in a \"cookie-cutter\" procedure and then removed. [MeshGeneratorMethods.f90/MarkExteriorElements] This gives a ragged boundary, which is smoothed.</li> <li>Boundary edges are then normally projected onto the boundary curves [MeshGeneratorMethods.f90/LocateEdgeImagesOnBoundaries], thereby creating boundary elements.  [MeshGeneratorMethods.f90/GenerateBoundaryElements]</li> <li>A topology cleanup is performed: High valence node elements are combined (Currently only valence 7) [MeshCleaner.f90/PerformTopologyCleanup/ReduceNodeValences] and diamond elements are collapsed. [MeshCleaner.f90/PerformTopologyCleanup/RemoveDiamondElements]. Many more topology cleanup methods have been proposed in the literature and could be added at this stage.</li> <li>The mesh is smoothed using a Smoother. [MeshSmoother.f90] contains the base class for a smoother. The LaplaceSmoother subclass doesn't really work yet. The workhorse is the spring-dashpot in [SpringMeshSmoother.f90].</li> <li>A final clean-up is performed [MeshCleaner.f90/PerformFinalMeshCleanup]. Bad elements are marked using a set of mesh quality analysis measures from the Verdict library: C. Simpson, C. D. Ernst, P. Knupp, P. P. P \u0301ebay, and D. C. Thompson. The Verdict Library Reference Manual. Sandia National Laboratories, April 2007.URL www.vtk.org/Wiki/images/6/6b/VerdictManual-revA.pdf.  Info about them is written to the Stats file. Chevron elements are removed with a template.</li> <li>A final smoothing is done</li> <li>Plot (for quick viewing) and mesh files are written.</li> </ol>"},{"location":"how-hohqmesh-works/#3d-mesh-generation","title":"3D Mesh Generation","text":"<p>Hex elements are created by extrusion of a 2D mesh. Three extrusions are possible:</p> <ul> <li>Simple Sweep: Sweep along a line in one of the three coordinate directions. [3DMeshController.f90/PerformSimpleMeshSweep]</li> <li>Simple Rotation: Rotate the 2D mesh through an angle about an axis. </li> <li>Sweep along a given curve. [SweeperClass.f90] Sweep can simply follow the curve [SweeperClass.f90/applyDefaultSweepTransform], which is fully accurate but can introduce twisting in the 3D mesh, or use a parallel transport algorithm [SweeperClass.f90/applyHansonSweepTransform] which eliminates the twist, but is only 2nd order accurate in following the sweep curve.</li> </ul>"},{"location":"introduction/","title":"TL;DR. What you can do with HOHQMesh","text":"<p>To use HOHQMesh to generate all-quadrilateral meshes with arbitrary order boundary elements you use a control file to</p> <ul> <li> <p>Define a <code>MODEL</code> consisting of</p> <ul> <li>An optional closed outer boundary curve made up of one or a chain of curved segments defined by primitives like straight line segments, circular arcs, elliptic arcs, splines, or equations</li> <li>Zero or more closed inner boundary curves defined in the same way</li> <li>Zero or more internal boundary curves that define boundaries for multiple material applications</li> <li>An optional bottom topography defined either in functional form or from a file to use to refine a 2D mesh around bottom features. (For example for shallow water equation computations.)</li> </ul> </li> <li> <p>Tell it how to mesh the model with a <code>CONTROL_INPUT</code> section to control the meshing process by</p> </li> <li>Setting run parameters that specify where to write the results, specify the mesh and plot file formats and the polynomial order of the boundary curves</li> <li>Setting a background grid size to specify the largest element size desired</li> <li>Setting how the mesh should be smoothed</li> <li>Defining optional refinement regions to allow manual refinement of the mesh to emphasize specific regions not indicated by the boundary curves or topography.</li> </ul> <p>HOHQMesh will automatically generate a mesh with curved elements sized according to the geometry, like the curvature of the boundary curves and bottom topography, and the distance between boundary curves. It will generate a mesh that is symmetric about a symmetry line if segments of the outer boundary are defined as symmetry boundaries.</p> <p>Additionally, you can generate an all hexahedral mesh by extruding a quadrilateral mesh by</p> <ul> <li>Simple extrusion along a coordinate direction</li> <li>Simple rotation about an axis</li> <li>Sweeping a quadrilateral mesh along a curve and optionally scaling the width along the way</li> </ul> <p>One can have the bottom of a hexahedral mesh follow a prescribed topography defined in functional form or from data. A 3D mesh can also be sized according to the curvature of the bottom topography.</p>"},{"location":"introduction/#introduction","title":"Introduction","text":"<p>Multidomain spectral methods, of which spectral element methods (SEMs) are a subclass, were introduced by Patera  (for elliptic and parabolic equations) and by Kopriva (for hyperbolic systems) to increase the efficiency of spectral methods and to apply them to complex geometries. Although somewhat controversial at the time -- questions were raised whether it was wise to not use the highest order polynomial possible  for a given number of degrees of freedom -- the methods have become so commonly used within the community that the updated book by Canuto et al.  is subtitled  \u201cFundamentals in Single Domains.\u201d</p> <p>The features of spectral element methods are now well-established. Like low order finite element methods, they can be applied to general geometries, but have exponential convergence in the polynomial order. Discontinuous Galerkin (DGSEM) versions applied to hyperbolic problems have exponentially low dissipation and dispersion errors, making them well suited for wave propagation problems. They are also especially suitable when material discontinuities are present. Approximations exist for high order quad/hex and tri/tet elements. Numerous examples of the flexibility and the power of spectral element methods can be found in Canuto et al.\u2019s third volume subtitled \u201cEvolution to Complex Geometries\u201d. Textbooks on the subject now exist, such as those by Deville, Fischer and Mund, Sherwin and Karniadakis , Hesthaven and Warburton, and Kopriva.</p> <p>What some are now calling \u201cclassical\u201d spectral element methods use tensor product bases on quadrilateral or hexahedral meshes. These bases lead to very efficient implementations and have high order quadratures that can be used to approximate the integrals found in weak forms of the equations. The methods are being used in a wide variety of fields including fluid dynamics, electromagnetics, geophysics, and fluid-structure interaction problems, just to name a few.</p> <p>Unfortunately, meshes for quad/hex elements are considered to be difficult to generate even for low order finite element approximations. This has lead to the development of triangular/tetrahedral spectral element bases. These methods can adapt the meshes generated by virtually all mesh generation packages today in two and three space dimensions. What one gives up in trade is the efficiency of the derivative evaluations, the Gauss quadratures, and meshes well-suited for boundary layer computations.</p>"},{"location":"introduction/#spectral-element-grid-generation","title":"Spectral Element Grid Generation","text":"<p>The advantages not withstanding, a major frustration in - and impediment to - the application of spectral element methods has been the lack of appropriate general purpose mesh generation software. A survey of the literature, practitioners, and user manuals for available spectral element software packages such as SemTex, SEM2DPack, or Nekton, highlights these difficulties. Blackburn's SemTex page http://users.monash.edu.au/~bburn/semtex.html notes that \u201cMesh generation can be a significant hurdle to new users\u201d and includes \u201ca number of example meshes ... (most of which were generated by hand).\u201d SEM2DPack's manual says it \u201ccan only generate a structured mesh for a single quadrilateral domain, possibly with curved sub-horizontal boundaries and curved sub-horizontal layer interfaces.\u201d Sherwin and Peiro's comment:  \u201cThe ability to construct suitable computational meshes is currently a significant limiting factor in the development of compact high-order algorithms in very complex geometries\u201d still holds today. Canuto et al. do not even broach the subject.</p> <p>Simply put, and avoiding the common colloquialism, the state of the art in spectral element grid generation has been dismal. One finds that spectral element meshes are either generated \u201cby hand\u201d, by special purpose mesh generators, or by low order finite element packages. Examples of hand generated meshes can be found in the textbooks listed above, for instance. SEM2DPack interfaces with the low order finite element mesh generator EMC2. The Nekton and SemTex packages interface with the finite element package GMSH. But the situation is particularly difficult for ``classical'' quad and hex element codes since even low order finite element mesh generators for these elements are hard to find. A consequence is that one even finds meshes in the literature that are simple quad/hex decompositions of low order triangular/tetrahedral meshes. The meshes that practitioners generate differ greatly from those generated by finite element mesh generators. The reason is not just a matter of the tedium associated with the process. Spectral element approximations encourage the use of larger elements with curved boundaries approximated at high order. Meshes generated by hand or with simple templates tend to have fewer and larger elements.</p> <p>Meshes generated by finite element packages designed for low order elements generate huge numbers of small elements and do not exploit the efficiency of high order spectral element approximations. The use of standard generators can lead one to use a high order method, yet approximate curved boundaries as segments of straight lines. Commercial mesh generators that generate \u201chigher order elements\u201d, e.g.  PATRAN, GMSH or Gambit, do exist, but high order usually means third order, tops. ICEM-HEXA will guarantee quad/hex spectral element type meshes only for block structured meshes. The costs of commercial packages, however, are so far above the budgets provided by the typical NSF grant or mathematics department and so aren\u2019t an option even if they could generate spectral element meshes.</p>"},{"location":"introduction/#hohqmesh","title":"HOHQMesh","text":"<p>For these reasons we have developed the High Order Hex-Quad Mesh (HOHQMesh) package to automatically generate all-quadrilateral meshes with high order boundary information to be used in spectral element computations. It also can take such two dimensional meshes and extrude them in the normal direction to general all hex meshes for simple extrusion type geometries.</p>"},{"location":"introduction/#example-meshes","title":"Example Meshes","text":"<p>Before going into details, we show some meshes that have been generated by HOHQMesh. Control files for generating these meshes can be found in the Examples directory. Some of the meshes show internal spectral element degrees of freedom and the fully accurate boundary representations. Others show only the quad or hex shape of the elements as given in the plot file generated by the program.</p> <p>The first example is a full spectral element mesh for three circles within an outer circle. HOHQMesh is fully automatic and sizes the elements according to the geometry.</p> <p></p> <p> Fig. 1. Sixth order spectral element mesh of three circles within a circle (Examples/2D/Circles3)</p> <p>The second example example shows that general curves can be used to define the boundaries. This time, a set of points and a spline are use to define the outer boundary. </p> <p> Fig. 2. Eighth order spectral element mesh of a domain bounded by a spline curve (Examples/2D/Spline)</p> <p>HOHQMesh has templates to automatically mesh around sharp corners. </p> <p> Fig. 3. Spectral element mesh of a domain with sharp corners (Examples/2D/CavityRamp)</p> <p>This makes it possible to mesh airfoil type geometries. </p> <p> Fig. 4. Mesh of a NACA0012 airfoil (Examples/2D/NACA0012)</p> <p></p> <p> Fig. 5. Mesh for a three element Karman-Trefftz airfoil (Examples/2D/KT3Element)</p> <p>Local refinement can be added manually, either at a point or along a line. </p> <p> Fig. 6. Mesh showing manual refinement along a line and at a point (Examples/2D/AllFeatures)</p> <p>Truly complex geometries can be meshed, as shown in the following coastline models. Refinement around features is automatic. </p> <p> Fig. 7. The Indian Ocean (Examples/2D/IndianOcean)</p> <p></p> <p> Fig. 8. Lake Superior with spectral element nodes shown (Examples/2D/LakeSuperior)</p> <p>In some applications, such as if there are regions in which the material properties change abruptly, one may want to include interior interface curves to ensure that element boundaries fall along those curves. Fig. 9 shows a circular domain with two interior circular domains that are separated by interface curves.</p> <p></p> <p> Fig. 9. Mesh with interior interfaces bounded by circles.</p> <p>Finally, hex meshes can also be created by sweeping a quad mesh. The simplest way is to extrude a two-dimensional mesh in one of the coordinate directions.</p> <p></p> <p> Fig. 10. Simple extrusion of the mesh in Fig. 3 (Examples/3D/CavityRampExtruded)</p> <p>Or the mesh can be rotated along a coordinate axis through a specified angle,</p> <p></p> <p> Fig. 11. Simple rotation of the mesh in Fig. 3</p> <p>More sophisticated extrusions can be created by sweeping along a curve,</p> <p></p> <p> Fig. 12. Hex mesh generated by sweeping along a curve (Examples/3D/Snake)</p> <p>Finally, swept meshes can also be scaled along the curve. </p> <p> Fig. 13. Hex mesh generated by sweeping and scaling along a curve</p> <p>All told, the geometries that can be meshed can be quite general. </p> <p> Fig. 14. Quad mesh of a gingerbread man with spectral element nodes shown (Examples/2D/GingerbreadMan)</p>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2010-present David A. Kopriva and other contributors: Authors</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p> <p>HOHQMesh contains code that, to the best of our knowledge, has been released as public domain software:</p> <ul> <li><code>b3hs_hash_key_jenkins</code>: originally by Rich Townsend, https://groups.google.com/forum/#!topic/comp.lang.fortran/RWoHZFt39ng, 2005</li> </ul>"},{"location":"releasing-a-new-version/","title":"Releasing a New Version","text":"<p>This document describes the necessary steps for creating a new HOHQMesh release. When following these guidelines, don't forget to replace <code>1.2.3</code> with the current release version of HOHQMesh, and <code>1.3.0</code> with the new release you are about to create.</p> <p>Note: All steps as described here are assumed to be performed in a clean clone of the <code>main</code> branch. Otherwise the creation of the release tarball will fail!</p>"},{"location":"releasing-a-new-version/#pre-release-preparations","title":"Pre-release preparations","text":"<ol> <li>Ensure that the current HOHQMesh commit on <code>main</code> has passed all tests on    GitHub by verifying that there is a green checkmark behind the latest commit on    https://github.com/trixi-framework/HOHQMesh/commits/main.</li> <li>Enter the HOHQMesh clone directory, switch to <code>main</code>, and pull the latest version from GitHub:    <pre><code>cd HOHQMesh\ngit checkout main\ngit pull\n</code></pre></li> <li>Ensure that the latest version of <code>FTObjectLibrary</code> is present in the <code>Contrib</code>    directory by calling the <code>bootstrap</code> script:    <pre><code>./Utilities/bootstrap\n</code></pre></li> <li>Get the latest HOHQMesh version tag by executing    <pre><code>git tag --list 'v*' --sort -version:refname | head -n1\n</code></pre>    This will yield something like <code>v1.2.3</code>, where <code>1.2.3</code> is the version number    and the <code>v</code> prefix indicates that this is really a version tag.</li> <li>Compare this with the    latest release    on GitHub. If the version numbers of the latest tag and the latest release    differ, investigate (and possibly fix it) before proceeding.</li> <li>Determine which kind of version increment is necessary based on the changes    since the last release. We use semantic versioning,    which states <p>Given a version number MAJOR.MINOR.PATCH, increment the:</p> <p>MAJOR version when you make incompatible API changes, MINOR version when you add functionality in a backwards compatible manner, and PATCH version when you make backwards compatible bug fixes.</p> </li> </ol> <p>To see all the changes since the last release, you can use GitHub's <code>compare</code>    functionality by navigating to the following address, adjusting the version    tag appropriately:    https://github.com/trixi-framework/HOHQMesh/compare/v1.2.3...main    If you prefer to work to work locally in a console, you can execute    <pre><code>git diff v1.2.3\n</code></pre>    Let's say that the changes require a minor version increment, thus the new    release version following <code>1.2.3</code> would be <code>1.3.0</code>.</p>"},{"location":"releasing-a-new-version/#release-creation","title":"Release creation","text":"<ol> <li>Increment the version number in <code>Source/HOHQMeshMain.f90</code>.    The current version in the file should be something like <code>1.2.4-pre</code>,    indicating that the <code>main</code> branch is in a pre-release state (as it should be    during development). Change the pre-release version string to the new version    number you determined above, e.g., to <code>1.3.0</code>:    <pre><code>CHARACTER(LEN=*), PARAMETER :: version           = \"1.3.0\"\n</code></pre></li> <li>Commit and push to <code>main</code> (make sure to use your version number!):    <pre><code>git add Source/HOHQMeshMain.f90\ngit commit -m 'Increment version to v1.3.0'\ngit push\n</code></pre></li> <li>Ensure that you did not accidentally break anything and verify that there is    a green checkmark behind the latest commit on    https://github.com/trixi-framework/HOHQMesh/commits/main.</li> <li>Create a new release tarball by executing    <pre><code>./Utilities/createrelease 1.3.0\n</code></pre>    where <code>1.3.0</code> again refers to the new release version (without the <code>v</code>    prefix!). This will result in a new file <code>HOHQMesh-v1.3.0.tar.gz</code> in the    current directory.</li> <li>Test the new release by executing    <pre><code>FC=gfortran ./Utilities/testrelease HOHQMesh-v1.3.0.tar.gz\n</code></pre>    Make sure you change the Fortran compiler executable to one suitable    for your system by modifying the <code>FC</code> environment variable accordingly.    If it fails, do not just change the files in your current directory!    Instead, figure out why the tests fail, fix them, commit and push the changes    and start over.</li> <li>Create a new annotated Git tag and push it to GitHub (make sure to include    the <code>v</code> prefix and to use your version number both for the tag and the    message!):    <pre><code>git tag -a v1.3.0 -m \"HOHQMesh v1.3.0\"\ngit push --tags\n</code></pre></li> <li>Navigate to https://github.com/trixi-framework/HOHQMesh/releases/new to start    creating a new release.</li> <li>Enter <code>v1.3.0</code> as the <code>Tag version</code>, which should find the Git tag you    just created.</li> <li>Use <code>HOHQMesh v1.3.0</code> as the <code>Release title</code>.</li> <li>Feel free to add more information about this release in the description field    (optional).</li> <li>Attach the file you just created to the new release by dragging and     dropping the tarball <code>HOHQMesh-v1.3.0.tar.gz</code> in the gray area below the     release description.</li> <li>Click <code>Publish release</code>.</li> </ol>"},{"location":"releasing-a-new-version/#post-release-actions","title":"Post-release actions","text":"<ol> <li>Increment the version number in <code>Source/HOHQMeshMain.f90</code> to a pre-release    version to indicate that the current content of the <code>main</code> branch does not    necessarily reflect the files of an existing, tagged release. The pre-release    version is generated by incrementing the current patch version and appending <code>-pre</code>.    For example, if you just created the release <code>1.3.0</code>, the next pre-release    version would be <code>1.3.1-pre</code>.</li> <li>Commit and push to <code>main</code> (make sure to use your version number!):    <pre><code>git add Source/HOHQMeshMain.f90\ngit commit -m 'Set development version to v1.3.1-pre'\ngit push\n</code></pre></li> <li>Consider updating the Spack package specifications.</li> </ol>"},{"location":"the-control-file/","title":"The Control File","text":"<p>The <code>MODEL</code> and the <code>CONTROL_INPUT</code> blocks described above are put into a single file called the control file, which is finished with a <code>\\end{FILE}</code> command. An example of a full control file that meshes a model with a circular outer boundary and two inner circular boundaries, and writes out a plot file with spectral element resolution, is shown below. There is also a template control file in the Examples directory.</p> <p>Just some notes: </p> <ol> <li>Blocks do not have to be specified in any order (e.g. the <code>MODEL</code> could come first before the <code>CONTROL_INPUT</code>. <code>INNER_BOUNDARIES</code> could come before <code>OUTER_BOUNDARY</code>. Blocks must be defined within their appropriate block however, e.g. <code>OUTER_BOUNDARY</code> can only be defined in a <code>MODEL</code> block.</li> <li>Keywords within a block can be specified in any order. The only ordering that is important is that within a <code>CHAIN</code>, the curves must be specified in order, counter-clockwise. </li> <li>Spaces in keywords are significant, but not in any other contexts. For instance equals signs are aligned only for visual formatting.</li> <li>Blank lines or lines starting with % are ignored.</li> </ol> <pre><code>\\begin{CONTROL_INPUT}\n\n   \\begin{RUN_PARAMETERS}\n      mesh file name         = Circles3Mesh.mesh\n      plot file name         = Circles3Plot.tec\n      statistics file name   = Circles3Stats.txt\n      mesh file format       = ISM\n      polynomial order       = 6\n      plot file format       = sem\n   \\end{RUN_PARAMETERS}\n\n   \\begin{BACKGROUND_GRID}\n     background grid size = [4.0,4.0]\n   \\end{BACKGROUND_GRID}\n\n   \\begin{SPRING_SMOOTHER}\n     smoothing type       = LinearAndCrossbarSpring\n     number of iterations = 20\n   \\end{SPRING_SMOOTHER}\n\n\\end{CONTROL_INPUT}\n\n\\begin{MODEL}\n\n    \\begin{OUTER_BOUNDARY}\n        \\begin{PARAMETRIC_EQUATION_CURVE}\n            name = outer\n            xEqn = x(t) = 14.0*cos(2*pi*t)\n            yEqn = y(t) = 14.0*sin(2*pi*t)\n            zEqn = z(t) = 0.0\n        \\end{PARAMETRIC_EQUATION_CURVE}\n    \\end{OUTER_BOUNDARY}\n\n    \\begin{INNER_BOUNDARIES}\n\n        \\begin{CHAIN}\n            name = Boundary 1\n            \\begin{PARAMETRIC_EQUATION_CURVE}\n                    name = Circle1\n                    xEqn = f(t) = -10.25 + 0.2*cos(2*pi*t)\n                    yEqn = f(t) = 3.0 + 0.2*sin(2*pi*t)\n                    zEqn = z(t) = 0.0\n            \\end{PARAMETRIC_EQUATION_CURVE}\n        \\end{CHAIN}\n\n        \\begin{CHAIN}\n            name = Boundary 2\n           \\begin{PARAMETRIC_EQUATION_CURVE}\n                name = Circle2\n                xEqn = f(t) = -5.1 + 1.0*cos(2*pi*t)\n                yEqn = f(t) = 1.0*sin(2*pi*t) - 4.1\n                zEqn = z(t) = 0.0\n            \\end{PARAMETRIC_EQUATION_CURVE}\n        \\end{CHAIN}\n\n        \\begin{CHAIN}\n            name = Boundary 3\n            \\begin{PARAMETRIC_EQUATION_CURVE}\n                name = Circle3\n                xEqn = f(t) = -12.0 + 0.5*cos(2*pi*t)\n                yEqn = f(t) = 0.5*sin(2*pi*t) - 0.5\n                zEqn = z(t) = 0.0\n            \\end{PARAMETRIC_EQUATION_CURVE}\n        \\end{CHAIN}\n    \\end{INNER_BOUNDARIES}\n\\end{MODEL}\n\\end{FILE}\n</code></pre>"},{"location":"the-control-input/","title":"The Control Input","text":"<p>The meshing of the model is controlled by the <code>CONTROL_INPUT</code> block of the input control file, which gives all of the commands needed to mesh the model. Actually, there are not a lot of commands at the moment, so that\u2019s not too bad. The control block is</p> <pre><code>\\begin{CONTROL_INPUT}\n...\n\\end{CONTROL_INPUT}\n</code></pre> <p>Inside the control input block the <code>RUN_PARAMETERS</code>, <code>BACKGROUND_GRID</code>, <code>SMOOTHER</code>, and any number of <code>REFINEMENT_CENTER</code>s and <code>REFINEMENT_LINE</code>s  are defined.</p>"},{"location":"the-control-input/#the-run-parameters","title":"The Run Parameters","text":"<p>The <code>RUN_PARAMETERS</code> block defines the file information and the polynomial order at which the boundary curves will be defined in the mesh file. Three files can be output by the mesher. The first listed below is the actual mesh file. The second is a tecplot format file that can be used to visualize the mesh. The free programs VisIt or Paraview can be used to plot tecplot files. The final file (optional) is to report mesh statistics, like the distribution of largest angle, Jacobian, etc. See the \u201cVerdict Library Reference Manual\u201d by Stimpson et al. if you are interested to learn about the different shape quality measures. Include a unix style path to choose the directory for the results.</p> <p>The RUN_PARAMETERS block is:</p> <pre><code>\\begin{RUN_PARAMETERS}\n    mesh file name   = MeshFileName.mesh\n    plot file name   = PlotName.tec\n    stats file name  = StatsName.txt\n    mesh file format = ISM *OR* ISM-v2 *OR* ISM-MM *OR* ABAQUS\n    polynomial order = 6\n    plot file format = skeleton *OR* sem\n\\end{RUN_PARAMETERS}\n</code></pre> <p>The names can be anything, since they are simply text files. However the \u201c.tec\u201d extension on the plot file will help VisIt/Paraview know how to read it. If you don\u2019t want a file created, simply choose the name to be none.</p> <p>In the current version of  HOHQMesh, there are four mesh file formats, \u201cISM\u201d which stands for \u201cImplementing Spectral Methods\u201d . This is the file format described in the book by David A. Kopriva. The other available formats are \u201cISM-v2\u201d, which provides the edge information needed by the approximations so that the edge generation algorithms in the appendix of the book are not needed, \"ISM-MM\", which associates a material name with an element, and \"ABAQUS\", which provides the corner nodes and element connectivity data in the specific Abaqus file format. See the corresponding sections in the \"HOHQMesh Mesh File Formats\" section of this manual for a description of the information they each provide. In the future, other file formats may be implemented, too. Finally, high order boundary information is conveyed by outputting an interpolant of the specified order. That information can be viewed using the \u201csem\u201d plot file format. Note that the sem formatted files can get rather large.</p>"},{"location":"the-control-input/#the-background-grid","title":"The Background Grid","text":"<p>The meshing algorithm starts with a uniform background grid. If an outer boundary is specified in the model, HOHQMesh will create this background grid using the extents of the outer boundary and the background grid size specified in the <code>BACKGROUND_GRID</code> block. If there is no outer boundary, then the background grid must be specified in the control input. The <code>BACKGROUND_GRID</code> block specifies the coordinates of the lower left corner of the grid, the grid size in each coordinate direction, and the number of  grid cells in each direction:</p> <pre><code>\\begin{BACKGROUND_GRID}\n    x0 = [-10.0, -10.0, 0.0]\n    dx = [2.0, 2.0, 0.0]\n    N  = [10,10,0]\n\\end{BACKGROUND_GRID}\n</code></pre> <p>If there is no <code>MODEL</code> block, then the <code>BACKGROUND_GRID</code> block will define the Cartesian mesh that will be generated, with the lower left point located at x0, grid spacing dx, and N elements in each direction. For now, the z components must be zero so that the grid is in the x-y plane.</p> <p>The example above creates a uniform background grid with lower left corner at (-10,10) and upper right corner at (10,10).</p> <p>Alternatively, if there is an outer boundary curve, you want to specify the background grid size and let HOHQMesh compute the rest of the parameters:</p> <pre><code>\\begin{BACKGROUND_GRID}\n    background grid size = [2.0,2.0,0.0]\n\\end{BACKGROUND_GRID}\n</code></pre> <p>This is the equivalent of dx in the previous incarnation.</p> <p>Note: In general you want to choose the grid size to be the same in each direction for the algorithms that make the mesh conforming to work properly. They can differ if a Cartesian mesh is being generated.</p>"},{"location":"the-control-input/#the-smoother","title":"The Smoother","text":"<p>It is generally necessary to smooth the mesh after it is generated. Smoothing is done by the Smoother.</p> <p>The <code>SPRING_SMOOTHER</code> uses a spring-dashpot model and time relaxation to smooth the mesh, see Discontinuous Galerkin spectral element approximations on moving meshes by Cesar A. Acosta Minoli, David A. Kopriva. There are two spring topologies \u201cLinearSpring\u201d and \u201cLinearAndCrossbarSpring\u201d. The first only has springs between the nodes along the edges. The latter also puts springs along the diagonals of an element. The latter is preferred. The springs have a spring constant associated with them and a dashpot with a damping coefficient. The nodes have mass. The linear ODE system that describes the motion of the nodes is integrated with a forward Euler (Explicit!) approximation for which a time step and number of time steps are given. The <code>SPRING_SMOOTHER</code> block, if one is used (Recommended!)  is</p> <pre><code>\\begin{SPRING_SMOOTHER}\n    smoothing            = ON **or** OFF (Optional)\n    smoothing type       = LinearAndCrossbarSpring **or** LinearSpring\n    spring constant      = 1.0 (Optional)\n    mass                 = 1.0 (Optional)\n    rest length          = 0.0 (Optional)\n    damping coefficient  = 5.0 (Optional)\n    number of iterations = 20\n    time step            = 0.1 (Optional)\n\\end{SPRING_SMOOTHER}\n</code></pre> <p>Just leave out any of the optional parameters if you want the default values to be used. The default values should be sufficient, but the additional flexibility might be useful on occasion. (The architecture is designed for developers to add different (better!) smoothers, and hence the name \"SPRING_SMOOTHER\".)</p>"},{"location":"the-control-input/#refinement-regions","title":"Refinement Regions","text":"<p> Fig. 19. Two refinement centers and a refinement line</p> <p>Mesh sizing is done automatically according to the curvature of boundary curves and the curvature of a bottom topography that can be supplied. See the section on topography for more information on the latter.</p> <p>Manual scaling of the mesh size can be performed by including any combination of</p> <ul> <li>Refinement Centers</li> <li>Refinement Lines</li> </ul>"},{"location":"the-control-input/#refinement-centers","title":"Refinement Centers","text":"<p>It is possible to ask HOHQMesh to locally refine the mesh at particular locations. This is done with a <code>REFINEMENT_CENTER</code> placed as desired. Two types of centers are available. One is \u201csmooth\u201d, which refines near a specified point and gradually de-refines towards the neighboring mesh size. The other is \u201csharp\u201d, which keeps the refined size in the neighborhood of the center. The desired mesh size and the size of the center are also parameters. An example of a refinement center is</p> <pre><code>\\begin{REFINEMENT_CENTER}\n    type = smooth **or** sharp\n    x0   = [1.0,1.0,0.0]\n    h    = 0.20\n    w    = 0.5\n\\end{REFINEMENT_CENTER}\n</code></pre> <p>This will place a center at (1,1,0) with mesh size of 0.2 over a circular region of radius  0.5 . Any number of RefinementCenters can be included. The order in which they are defined is not important.</p>"},{"location":"the-control-input/#refinement-lines","title":"Refinement Lines","text":"<p>The mesh can also be refined along a line using a <code>REFINEMENT_LINE</code>. Like the centers, there are two types, \u201csmooth\u201d and \u201csharp\u201d. To refine along a line, include a block of the form</p> <pre><code>\\begin{REFINEMENT_LINE}\n    type = smooth **or** sharp\n    x0 \u00a0\u00a0= [-3.5,-3.5,0.0]\n    x1 \u00a0\u00a0= [3.0,3.0,0.0]\n    h \u00a0\u00a0\u00a0= 0.20\n    w \u00a0\u00a0\u00a0= 0.5\n\\end{REFINEMENT_LINE}\n</code></pre> <p>Here, x0 and x1 are the starting and ending points of the line, h is the desired mesh size and w tells how far out from the line the refinement extends. An example of center and line refinements can be seen in Fig. 16.</p>"},{"location":"the-control-input/#refinement-region-definition","title":"Refinement Region Definition","text":"<p>Refinement regions are defined within a <code>REFINEMENT_REGIONS</code> block, e.g.</p> <pre><code>\\begin{REFINEMENT_REGIONS}\n\n  \\begin{REFINEMENT_LINE}\n      type = nonsmooth\n      x0   = [-3.0,-3.0,0.0]\n      x1   = [3.0,3.0,0.0]\n      h    = 0.3\n      w    = 0.3\n   \\end{REFINEMENT_LINE}\n\n   \\begin{REFINEMENT_CENTER}\n      type = smooth\n      x0   = [3.0,-3.0,0.0]\n      h    = 0.1\n      w    = 0.3\n   \\end{REFINEMENT_CENTER}\n\n\\end{REFINEMENT_REGIONS}\n</code></pre> <p>The ordering of the blocks within the <code>REFINEMENT_REGIONS</code> block is arbitrary.</p>"},{"location":"the-control-input/#base-material-definition","title":"Base Material Definition","text":"<p>If the ISM-MM mesh file format is requested to produce multiple material meshes, the material name for a given region is given by the name of the curve bounding it, except for the outermost region. For the outermost region it is necessary to set the background material name in a <code>MATERIALS</code> block, e.g.</p> <pre><code>\\begin{MATERIALS}\n  background material name = Muscle\n\\end{MATERIALS}\n</code></pre> <p>If the ISM-MM format is requested and a background material name is not supplied, a warning is posted and the background name 'base' is used.</p>"},{"location":"the-model/","title":"The Model","text":"<p>At the present time, HOHQMesh is designed to generate quadrilateral meshes in general two dimensional geometries like those shown below in Fig. 15, and extrusions thereof to get three dimensional hex meshes.</p> <p></p> <p> Fig. 15. Meshable regions</p>"},{"location":"the-model/#boundaries","title":"Boundaries","text":"<p>The two dimensional domain to be meshed can be bounded by at most one exterior boundary curve (which can be composed of a chain of curves), as in 15(a) and 15(b), above, and any number of interior boundary curves that either create holes or interfaces along which element edges are forced to lie. For purely external problems, a rectangular outer boundary can be implicitly included, as shown in 15(c).</p> <p>If no model block is included at all, then a purely Cartesian mesh will be created using parameters set in the control file.</p> <p>As an example, the model in Fig. 16 has one outer boundary - the outer triangle - and four inner boundaries whose interiors are exterior to the mesh.</p> <p></p> <p> Fig. 16. A mesh whose model uses all curve types. Three `END_POINTS_LINE`s for the outer triangle. A `SPLINE_CURVE` for the free-form inner boundary, circles defined by a `PARAMETRIC_EQUATION_CURVE` and by a `CIRCULAR_ARC` curve, and an ellipse defined by an `ELLIPTIC_ARC` curve. (Examples/2D/AllFeatures).</p>"},{"location":"the-model/#internal-boundaries","title":"Internal Boundaries","text":"<p>It is also possible to include interface boundaries whose interiors are also meshed. This allows one to force element boundaries along curves and to assign different material properties to each region bounded by them. The property is named by the innermost boundary in which an element lies. An example of a domain with two interface boundaries is shown in Fig. 17. Right now, interface curves must be defined in the model definition from outer to inner to properly assign material names. Thus, the innermost circle in Fig. 17 is defined after its enclosing circle. This restriction can be removed by adding code to test whether a given curve lies within another.</p> <p></p> <p> Fig. 17. Mesh with interior interfaces bounded by circles.</p>"},{"location":"the-model/#symmetric-meshes","title":"Symmetric Meshes","text":"<p>The mesh generator generates unstructured meshes, and there is no reason in general why a mesh must be symmetric if the model is symmetric. Since symmetry can be a desirable feature, HOHQMesh allows one to define a symmetry boundary about which the mesh will be symmetric by setting boundary names as \":symmetry\" (with a colon, so as not to interfere with some other use of the name). The symmetry boundary must be a straight line (no matter how that is defined, see below) and multiple symmetry boundaries must be co-linear. What HOHQMesh does is take a model and mesh it. Then, if one or more of the outer boundary curves are named \":symmetry\", that mesh will be reflected about the symmetry line and the result will be a perfectly symmetric mesh, to within rounding error. An example is shown in Fig. 18. If the curve designated as \":symmetry\" is not straight, or if any of multiple lines so designated are not co-linear, then an error is posted and the mesh will not be reflected.</p> <p></p> <p> Fig. 18. A mesh (left) reflected about the red boundary line (right).</p>"},{"location":"the-model/#boundary-curves","title":"Boundary Curves","text":"<p>Boundaries include the outer boundary, any number of inner boundaries, and interface boundaries that mark material or other separations. No boundary can cross another boundary. Boundary curves are constructed as closed chains of parameterized curves, with the parameter in the interval [0,1], oriented counter-clockwise. The chains can have one or more segments as seen in Fig. 15. In Fig. 15a the outer boundary is constructed from six curves, whereas in Fig. 15b it is bounded by a single one. The inner boundaries in Fig. 15a are a single circle and a square constructed by a chain of four lines. In Fig. 16, the outer triangle is constructed as a chain of straight lines defined as <code>END_POINTS_LINE</code>s.</p> <p>A curve is defined by a block</p> <pre><code>\\begin{curve_type}\n    ...\n\\end{curve_type}\n</code></pre> <p>It is given a name so that boundary conditions can be applied segment-by-segment to a chain.</p> <p>Currently there are five types of curves that can be defined:</p> <ul> <li>Curves defined by equation components.</li> <li>Cubic spline interpolants of a set of nodal points.</li> <li>Straight lines between two points.</li> <li>Circular arcs.</li> <li>Elliptic arcs.</li> </ul> <p>Fig. 16 is an example that uses all four curve-type definitions (Examples/2D/AllFeatures).</p> <p>The architecture is designed for developers to easily add curve definitions in the future by creating subclasses of the SMCurveClass.</p>"},{"location":"the-model/#the-parametric-equation-curve-definition","title":"The Parametric Equation Curve Definition.","text":"<p>Curves can be defined by strings that define the equations for the (x,y,z) components of the curve using the <code>PARAMETRIC_EQUATION_CURVE</code> type. An example block for this kind of curve is</p> <pre><code>\\begin{PARAMETRIC_EQUATION_CURVE}\n    name = circle\n    xEqn = x(t) = 14.0*cos(2*pi*t)\n    yEqn = y(t) = 14.0*sin(2*pi*t)\n    zEqn = z(t) = 0.0\n\\end{PARAMETRIC_EQUATION_CURVE}\n</code></pre> <p>The first line defines the name, followed by the x- , y- and z- equation definitions. Right now, only two-dimensional meshes in the x-y plane can be generated, so the z=0 equation must be set this way. The example block defines a closed circular curve of radius 14 named \u201ccircle\u201d. The indenting is optional, as is the ordering of the keys within the block. The keywords are \u201cname\u201d, \u201cxEqn\u201d, etc. and must be spelled correctly or an error will be posted when the model is read in. The zEqn keyword line is optional and can be left out.</p> <p>The equations can be any legal representations of an equation as is standard in most computer languages. The first part, before the equals sign defines the parameter variable, in this case, t. On the right hand side is the formula that defines the curve. Exponentiation is defined as in BASIC, like t^2. For convenience, the constant pi is defined. Like BASIC, number literals are defined as double precision values. There are no integer quantities. Standard functions like sin, cos, tan, atan, log, log10, exp, etc. are also available for use.</p>"},{"location":"the-model/#the-spline-curve-definition","title":"The Spline Curve Definition","text":"<p>The second type of curve is the <code>SPLINE_CURVE</code> type, which fits a cubic spline to a set of knots at given parameter values. The parameterization does not have to be uniform. An example of a spline-defined curve is</p> <pre><code>\\begin{SPLINE_CURVE}\n    name = SplineBoundaryCurve\n    nKnots = 9\n    \\begin{SPLINE_DATA}\n        0.000000000000000 -3.50000000000000  3.50000000000000 0.0\n        3.846153846153846E-002 -3.20000000000000  5.00000000000 0.0\n        7.692307692307693E-002 -2.00000000000000  6.00000000000 0.0\n        0.769230769230769  0.000000000000000 -1.00000000000000 0.0\n        0.807692307692308 -1.00000000000000 -1.00000000000000 0.0\n        0.846153846153846 -2.00000000000000 -0.800000000000000 0.0\n        0.884615384615385 -2.50000000000000  0.000000000000000 0.0\n        0.923076923076923 -3.00000000000000  1.00000000000000 0.0\n        1.00000000000000 -3.50000000000000  3.50000000000000 0.0\n    \\end{SPLINE_DATA}\n\\end{SPLINE_CURVE}\n</code></pre> <p>As before, the first line after the \\begin is the name of the curve. It is followed by the number of nodes in the spline. The data columns that follow are the nodes given by t<sub>j</sub>,x<sub>j</sub>,y<sub>j</sub>,z<sub>j</sub>. This particular spline is closed, so the location of the last node is the same as the first. Again, the z<sub>j</sub> values must currently be zero to ensure that curves are in the x-y plane.</p> <p>The spline data can get rather large, so there is an option to read it from an external file. To read from a file, the <code>SPLINE_CURVE</code> block is</p> <pre><code>\\begin{SPLINE_CURVE}\n    name = SplineBoundaryCurve\n    file = `pathToFile`\n\\end{SPLINE_CURVE}\n</code></pre> <p>The data file will have the number of nodes as the first line, followed by the data, e.g.</p> <pre><code>    9\n    0.000000000000000 -3.50000000000000  3.50000000000000 0.0\n    3.846153846153846E-002 -3.20000000000000  5.00000000000 0.0\n    7.692307692307693E-002 -2.00000000000000  6.00000000000 0.0\n    0.769230769230769  0.000000000000000 -1.00000000000000 0.0\n    0.807692307692308 -1.00000000000000 -1.00000000000000 0.0\n    0.846153846153846 -2.00000000000000 -0.800000000000000 0.0\n    0.884615384615385 -2.50000000000000  0.000000000000000 0.0\n    0.923076923076923 -3.00000000000000  1.00000000000000 0.0\n    1.00000000000000 -3.50000000000000  3.50000000000000 0.0\n</code></pre> <p>An example where the curve data is read from a file can be found in Examples/2D/EastCoastUS.</p>"},{"location":"the-model/#endpoints-line-definition","title":"Endpoints Line Definition","text":"<p>The next type of curve is the <code>END_POINTS_LINE</code> type that takes two end points and puts a straight line between them. An example is</p> <pre><code>\\begin{END_POINTS_LINE}\n    name   = B1\n    xStart = [0.0,1.0,0.0]\n    xEnd   = [2.0,1.0,0.0]\n\\end{END_POINTS_LINE}\n</code></pre> <p>where the x,y,z values of the point are specified in the array denoted as [x,y,z]. For now, the z component must be 0.0.</p>"},{"location":"the-model/#circular-arc-curve","title":"Circular Arc Curve","text":"<p>Another type of curve defines a circular arc. The angles can be defined either in terms of degrees or radians. If the (optional) units keyword is not included, the default is radians.</p> <pre><code>\\begin{CIRCULAR_ARC}\n    name        = circle\n    units       = degrees\n    center      = [0.0,0.0,0.0]\n    radius      = 4.0\n    start angle = 0.0\n    end angle   = 180.0\n\\end{CIRCULAR_ARC}\n</code></pre>"},{"location":"the-model/#elliptic-arc-curve","title":"Elliptic Arc Curve","text":"<p>The final type of curve defines an elliptic arc. The angles can be defined either in terms of degrees or radians. If the (optional) units keyword is not included, the default is radians. The x and y radii are specified separately, and the (optional) rotation keyword may be passed to rotate the ellipse counterclockwise.</p> <pre><code>\\begin{ELLIPTIC_ARC}\n    name        = ellipse\n    units       = degrees\n    center      = [0.0,0.0,0.0]\n    xRadius     = 4.0\n    yRadius     = 2.0\n    start angle = 0.0\n    end angle   = 180.0\n    rotation    = 45.0\n\\end{ELLIPTIC_ARC}\n</code></pre>"},{"location":"the-model/#boundary-chains","title":"Boundary Chains","text":"<p>To allow complex boundary curves and to allow different portions of a boundary to have different boundary conditions applied, curves can be chained together into a closed curve. A chain is defined by curves specified (in order) within a</p> <pre><code>\\begin{CHAIN}\n...\n\\end{CHAIN}\n</code></pre> <p>block. Any number of curves can be chained together. The chain itself is also given a name. An example of a chain that defines the boundary of a unit square is</p> <pre><code>\\begin{CHAIN}\n    name = UnitSquare\n    \\begin{PARAMETRIC_EQUATION_CURVE}\n        name = bottom\n        xEqn = f(t) = t\n        yEqn = f(t) = 0\n        zEqn = f(t) = 0\n    \\end{PARAMETRIC_EQUATION_CURVE}\n\n    \\begin{PARAMETRIC_EQUATION_CURVE}\n        name = right\n        xEqn = f(t) = 1\n        yEqn = f(t) = t\n        zEqn = f(t) = 0\n    \\end{PARAMETRIC_EQUATION_CURVE}\n\n    \\begin{PARAMETRIC_EQUATION_CURVE}\n        name = top\n        xEqn = f(t) = 1-t\n        yEqn = f(t) = 1\n        zEqn = f(t) = 0\n    \\end{PARAMETRIC_EQUATION_CURVE}\n\n    \\begin{PARAMETRIC_EQUATION_CURVE}\n        name = bottom\n        xEqn = f(t) = 0\n        yEqn = f(t) = 1-t\n        zEqn = f(t) = 0\n    \\end{PARAMETRIC_EQUATION_CURVE}\n\\end{CHAIN}\n</code></pre> <p>Again, the indentation is for readability only, as is the line spacing between the blocks. (Blank lines and lines starting with \u201c%\u201d are ignored.) Also remember that the chain is defined counter-clockwise, and the curves within the chain must be ordered and oriented properly. Chains cannot be chained together. Rem: The use of <code>PARAMETRIC_EQUATION_CURVE</code>s in this example predates the addition of the <code>END_POINTS_LINE</code> curves, which would be simpler to use here.</p>"},{"location":"the-model/#bottom-topography","title":"Bottom Topography","text":"<p>A bottom topography can also be added to the model. The most obvious use is when generating three dimensional meshes, where the bottom follows a given profile. But topography can also be used to size the mesh, which is useful for the solution of two-dimensional shallow water flows.</p> <p>A bottom topography can be defined in one of two ways:</p> <ul> <li>By supplying a functional form, f(x,y)</li> <li>By supplying gridded data in a file</li> </ul>"},{"location":"the-model/#topography-from-a-functional-form","title":"Topography from a Functional Form","text":"<p>The simplest way to define the bottom topography is with an equation in a <code>TOPOGRAPHY</code> block, e.g.,</p> <pre><code>    \\begin{TOPOGRAPHY}\n       eqn = h(x,y) = x^2 + y^2\n       sizing = ON \\or\\ OFF (Optional)\n    \\end{TOPOGRAPHY}\n</code></pre> <p>The height function takes two arguments, which are the physical x-y coordinates, unlike the parametric coordinates that define boundary curves. The <code>sizing</code> key is optional, with the default being <code>OFF</code>.</p>"},{"location":"the-model/#topography-from-data","title":"Topography from Data","text":"<p>Alternatively, the bottom topography data can be read in from a file, e.g.,</p> <pre><code>    \\begin{TOPOGRAPHY}\n       data file = path/to/bottom_data.txt\n       sizing = ON \\or\\ OFF (Optional)\n    \\end{TOPOGRAPHY}\n</code></pre> <p>The <code>sizing</code> key is optional, with the default being <code>OFF</code>.</p> <p>From this data, a bicubic interpolation is used to compute the bottom topography information. Currently this strategy of bottom topography extrusion relies on gridded data. The data file is assumed to come as separate lists of the x coordinate points, with length \\(n\\), the y coordinate points, with length \\(m\\), and the z coordinate points where the grid data is ordered slice-by-slice in the y direction, with size \\(m \\times n\\). Below a small example is provided to clarify the data file format</p> <pre><code> ! Header with the number of points in the x and y direction\n  75 50\n ! x node values\n x1\n ...\n x75\n ! y node values\n y1\n ...\n y50\n ! z node values\n z1,1\n z2,1\n ...\n z50,1\n z1,2\n ...\n z50,2\n ...\n z1,75\n ...\n z50,75\n</code></pre>"},{"location":"the-model/#sizing-the-mesh-with-bottom-topography","title":"Sizing the Mesh with Bottom Topography","text":"<p>When</p> <pre><code>    sizing = ON\n</code></pre> <p>in a TOPOGRAPHY block, e.g.</p> <pre><code>    \\begin{TOPOGRAPHY}\n       eqn    = h(x,y) = x^2 + y^2\n       sizing = ON\n    \\end{TOPOGRAPHY}\n</code></pre> <p>a two-dimensional mesh is sized according to the curvature of the topography, but does not change the z values of the mesh. For an example, see the top portion of Fig. 26.</p>"},{"location":"the-model/#the-model-definition","title":"The Model Definition","text":"<p>The model (there is at most one) defines the region that is to be meshed. It is marked by</p> <pre><code>\\begin{MODEL}\n...\n\\end{MODEL}\n</code></pre> <p>If the control file does not contain a model block, a Cartesian mesh will be generated.</p> <p>The model contains at most one outer boundary chain and any number of inner boundary chains. The outer boundary chain (if there is one) is defined by</p> <pre><code>\\begin{OUTER_BOUNDARY}\n...\n\\end{OUTER_BOUNDARY}\n</code></pre> <p>Within the <code>OUTER_BOUNDARY</code> block is a list of boundary curves that form a chain. There is no need to explicitly chain (by way of <code>\\begin{CHAIN}</code>...<code>\\end{CHAIN}</code>) the curves for the outer boundary, as that is implied.</p> <p>Inner boundaries (if any) are defined within the block</p> <pre><code>\\begin{INNER_BOUNDARIES}\n...\n\\end{INNER_BOUNDARIES}\n</code></pre> <p>Within this block one defines as many curves or <code>CHAIN</code>s as there are inner boundaries. The order in which the <code>CHAIN</code>s or curves are defined is not important. Use a CHAIN if you want to chain multiple curves together to create a single inner boundary. Outside of a chain, a curve will define a single inner boundary by itself. Note that a standalone curve must close on itself.</p> <p>Interior interface boundary curves are defined inside the <code>INTERFACE_BOUNDARIES</code> block, as if they are interior boundaries,</p> <pre><code>\\begin{INTERFACE_BOUNDARIES}\n...\n\\end{INTERFACE_BOUNDARIES}\n</code></pre> <p>Interface boundaries, unlike interior boundaries, do not create holes in model domain or the mesh. Interface boundaries that are contained (embedded) in other interface boundaries must be defined within the block in order from outer to inner to properly define the material names. The ordering of interface boundaries that are not embedded in another is not important. (Additions to HOHQMesh to remove this restriction will require code to determine whether or not a given curve is embedded within another, and has not yet been implemented. HOHQMesh essentially uses a painters algorithm to specify the material names.) If interface curves are not being used to delineate material boundaries (i.e. for mesh alignment alone and not with the ISM-MM mesh file format), then the ordering is unimportant.</p> <p>Bottom topography, if any, is defined in the <code>MODEL</code> inside a <code>TOPOGRAPHY</code> block, for either 2D (for sizing purposes) or 3D (to vary the bottom elevation) meshes,</p> <pre><code>\\begin{TOPOGRAPHY}\n...\n\\end{TOPOGRAPHY}\n</code></pre> <p>Two types of blocks are relevant only to three-dimensional meshes. They are the</p> <pre><code>\\begin{SWEEP_CURVE}\n    ...\n\\end{SWEEP_CURVE}\n</code></pre> <p>which defines the curve along which a 3D sweep is made. The second is  a scale factor</p> <pre><code>\\begin{SWEEP_SCALE_FACTOR}\n    ...\n\\end{SWEEP_SCALE_FACTOR}\n</code></pre> <p>which allows the size of the mesh to vary along a sweep curve. Details on what these blocks do can be found in the 3D Meshing section.</p>"},{"location":"the-model/#example","title":"Example","text":"<p>As an example, the following defines a model that has a single circular outer boundary and three inner circular boundaries. Two of the curves are defined within a CHAIN (even though there is only a single curve within each). One of them is standalone. Note that between the blocks, comments can be inserted starting with \u201c%\u201d. As usual, indentation is for the reader\u2019s eyes only. Rem: This example also predates the addition of the <code>CIRCULAR_ARC</code> curve definition, which could be used to define the circles instead.</p> <pre><code>\\begin{MODEL}\n    \\begin{OUTER_BOUNDARY}\n        \\begin{PARAMETRIC_EQUATION_CURVE}\n            name = outer\n            xEqn = x(t) = 14.0*cos(2*pi*t)\n            yEqn = y(t) = 14.0*sin(2*pi*t)\n            zEqn = z(t) = 0.0\n        \\end{PARAMETRIC_EQUATION_CURVE}\n    \\end{OUTER_BOUNDARY}\n%\n%   Inner boundaries, if any, are any number of chains\n%   of curves. Each inner boundary is defined within a CHAIN.\n%\n    \\begin{INNER_BOUNDARIES}\n        \\begin{CHAIN}\n            name = Boundary 1\n            \\begin{PARAMETRIC_EQUATION_CURVE}\n                name = Circle1\n                xEqn = f(t) = -10.25 + 0.2*cos(2*pi*t)\n                yEqn = f(t) = 3.0 + 0.2*sin(2*pi*t)\n                zEqn = z(t) = 0.0\n            \\end{PARAMETRIC_EQUATION_CURVE}\n        \\end{CHAIN}\n\n        \\begin{PARAMETRIC_EQUATION_CURVE}\n            name = Circle2\n            xEqn = f(t) = -5.1 + 1.0*cos(2*pi*t)\n            yEqn = f(t) = 1.0*sin(2*pi*t) - 4.1\n            zEqn = z(t) = 0.0\n        \\end{PARAMETRIC_EQUATION_CURVE}\n\n       \\begin{CHAIN}\n         name = Boundary 3\n            \\begin{PARAMETRIC_EQUATION_CURVE}\n            name = Circle3\n            xEqn = f(t) = -12.0 + 0.5*cos(2*pi*t)\n            yEqn = f(t) = 0.5*sin(2*pi*t) - 0.5\n            zEqn = z(t) = 0.0\n          \\end{PARAMETRIC_EQUATION_CURVE}\n        \\end{CHAIN}\n    \\end{INNER_BOUNDARIES}\n\\end{MODEL}\n</code></pre>"},{"location":"three-dimensional-hexahedral-meshes/","title":"Three Dimensional Hexahedral Meshes","text":"<p>HOHQMesh can also generate 3D hexahedral meshes by extruding or sweeping a two dimensional mesh. Topography can also be added to the bottom of the domain either through a functional form or from data supplied through a file. Finally, when bottom topography is present, the mesh along the bottom can be sized according to the bottom curvature for either 2D or 3D meshes.</p> <p>To tell the mesher that you want a hex mesh, you add an algorithm block to the <code>CONTROL_INPUT</code> block for how the 3D extrusion will be done. Currently there are three:</p> <ul> <li>Simple extrusion,</li> <li>Simple rotation, and</li> <li>Sweeping.</li> </ul> <p>When sweeping is used, the profile can be scaled along the sweep.</p> <p>One unique feature of HOHQMesh is that bottom topography can be added when simple extrusion is used to generate the 3D mesh. Furthermore, the mesh can be sized according to the curvature of the bottom topography.</p>"},{"location":"three-dimensional-hexahedral-meshes/#simple-extrusion","title":"Simple Extrusion","text":"<p> Fig. 20. Simple Extrusion of a semi-circular quadrilateral mesh</p> <p>The first hex-meshing algorithm is the <code>SIMPLE_EXTRUSION</code> algorithm.</p> <pre><code>\\begin{SIMPLE_EXTRUSION}\n     direction          = 3\n     height             = 8.0\n     subdivisions       = 8\n     start surface name = bottom\n     end surface name   = top\n \\end{SIMPLE_EXTRUSION}\n</code></pre> <p>The direction (where x = 1, y = 2, z = 3) says which direction the extrusion is done. Note that even though the initial 2D mesh is in the x-y plane, the quad mesh is rotated to give a hex mesh extruded in the requested direction. The height tells how far to extrude. A name is given to the bottom and top faces created by the extrusion so that boundary conditions can be attached. Otherwise, the names of the faces are given by the 2D curve names.</p>"},{"location":"three-dimensional-hexahedral-meshes/#simple-rotation","title":"Simple Rotation","text":"<p> Fig. 21. Simple rotation of the mesh in Fig. 3</p> <p>The second algorithm is the <code>SIMPLE_ROTATION</code>, which rotates the two dimensional mesh about an  axis</p> <pre><code>\\begin{SIMPLE_ROTATION}\n   direction             = 1\n   rotation angle factor = 1.0\n   subdivisions          = 8\n   start surface name    = bottom\n   end surface name      = top\n\\end{SIMPLE_ROTATION}\n</code></pre> <p>The rotation angle factor is the fraction of pi over which the quad mesh is rotated. An example is shown above in Fig. 21 of an original two dimensional mesh and its rotation about the x axis (direction = 1).</p>"},{"location":"three-dimensional-hexahedral-meshes/#sweeping","title":"Sweeping","text":"<p> Fig. 22. Hex mesh generated by sweeping a circular mesh along a curve</p> <p>The most general algorithm for generating hex meshes in HOHQMesh is to sweep a two-dimensional mesh along a prescribed curve, <code>SWEEP_ALONG_CURVE</code>. To sweep along a curve, one does two things:</p> <ol> <li>Add  a <code>SWEEP_ALONG_CURVE</code> block to the <code>CONTROL_INPUT</code> block and</li> <li>Add the curve along which the sweeping is to be done to the <code>MODEL</code> block.</li> </ol> <p>There are currently two sweeping algorithms available. The default is a simple rotation algorithm that has no method to counteract twisting of the mesh as it follows the curve. (Think of a roller-coaster that can turn upside down as it follows a curved track.) The default algorithm is exact so will sweep the curve to high order, but will only produce an untwisted mesh if the curve is planar.</p> <p>The second is a parallel transport algorithm due to Hanson and Ma that keeps arbitrary vector in a particular orientation with respect to its initial direction. The parallel transport approach minimizes the twisting of the hex mesh, but is only second order accurate. [A fourth order algorithm exists and may be implemented in the future.]</p> <p>To implement sweeping, include a <code>SWEEP_ALONG_CURVE</code> block in the <code>CONTROL_INPUT</code> block:</p> <pre><code>\\begin{SWEEP_ALONG_CURVE}\n   algorithm                = Hanson (optional)\n   subdivisions per segment = 8\n   start surface name       = bottom\n   end surface name         = top\n\\end{SWEEP_ALONG_CURVE}\n</code></pre> <p>The algorithm keyword is optional. If not present, the sweeping will not include the parallel transport correction. Since the sweep curve can be a chain with slope or curvature singularities, the number of subdivisions per segment is defined. This ensures that a singularity occurs along element boundaries so that accuracy is not lost.</p> <p>The curve itself is defined in the <code>MODEL</code> block.</p> <pre><code>\\begin{SWEEP_CURVE}\n    ...\n\\end{SWEEP_CURVE}\n</code></pre> <p>The <code>SWEEP_CURVE</code> block implicitly defines a <code>CHAIN</code>, like the <code>OUTER_BOUNDARY</code> block, and so only needs a list of curves to define the sweep.</p>"},{"location":"three-dimensional-hexahedral-meshes/#scaling","title":"Scaling","text":"<p> Fig. 23. Hex mesh generated by sweeping and scaling along a curve</p> <p>The mesh can also be scaled in the direction normal to the sweep curve when sweeping is used. To scale the mesh, add a</p> <pre><code>\\begin{SWEEP_SCALE_FACTOR}\n    ...\n\\end{SWEEP_SCALE_FACTOR}\n</code></pre> <p>block to the <code>MODEL</code>. Like the <code>SWEEP_CURVE</code> and <code>OUTER_BOUNDARY</code> blocks, the <code>SWEEP_SCALE_FACTOR</code> block implicitly defines a <code>CHAIN</code>. You do not need to have the number chain segments match the number in the <code>SWEEP_ALONG_CURVE</code> block, but it is probably best to not introduce slope or curvature singularities except at element interfaces.</p> <p>The equation for the scaling is scalar <code>PARAMETRIC_EQUATION</code> (as opposed to a <code>PARAMETRIC_EQUATION_CURVE</code>). It is defined, for example like this:</p> <pre><code>    \\begin{PARAMETRIC_EQUATION}\n       eqn = r(t) = 1.0 + 2.5*t*(1-t)\n    \\end{PARAMETRIC_EQUATION}\n</code></pre>"},{"location":"three-dimensional-hexahedral-meshes/#bottom-topography","title":"Bottom Topography","text":"<p> Fig. 24. Simple Extrusion of a semi-circular mesh with bottom topography</p> <p>The bottom of a three dimensional mesh can vary in height according to a bottom topography. One defines the topography in the <code>MODEL</code> block in one of two ways:</p> <ul> <li>By supplying a functional form, f(x,y)</li> <li>By supplying gridded data in a file</li> </ul> <p>See the <code>MODEL</code> section for details. Fig. 24 above shows an example of a bottom topography set with a bottom function, while Figs. 25 and 26 use data to describe Mt. St. Helens. </p> <p></p> <p> Fig. 25. Simple Extrusion of a rectangular mesh with a mountain bottom topography read in from a file</p>"},{"location":"three-dimensional-hexahedral-meshes/#sizing-the-mesh-along-bottom-topography","title":"Sizing the Mesh along Bottom Topography","text":"<p> Fig. 26. Simple Extrusion of a semi-circular mesh with a bottom topography and local refinement depending on its curvature</p> <p>When</p> <pre><code>    sizing = ON\n</code></pre> <p>in a TOPOGRAPHY block, e.g.</p> <pre><code>    \\begin{TOPOGRAPHY}\n       eqn    = h(x,y) = x^2 + y^2\n       sizing = ON\n    \\end{TOPOGRAPHY}\n</code></pre> <p>the sizer will size the grid along the bottom according to the curvature of the topography for a 3D mesh. An example is shown in Fig. 26. If only a two dimensional mesh is requested, then it is sized according to the curvature, but the z-values of the 2D mesh are not changed, the result looking like the top of Fig. 26.</p>"},{"location":"updating-spack-packages/","title":"Updating Spack Packages","text":"<p>When new releases of HOHQMesh are made, you can contribute the new release to the spack packages. Before making an update to the Spack package, you should familiarize yourself with the Spack packaging guide.</p> <p>To add a new HOHQMesh release to Spack, perform the following steps:</p> <ol> <li> <p>Fork the Spack repository on GitHub.</p> </li> <li> <p>Install and initialize spack on your local system from your fork    <pre><code>git clone https://github.com/YOUR GITHUB ACCOUNT/spack.git ~/spack\nsource ~/spack/share/spack/setup-env.sh\n</code></pre></p> </li> <li> <p>Open the HOHQMesh package for editing    <pre><code>spack edit hohqmesh\n</code></pre></p> </li> <li> <p>Add a new <code>version</code> metadata item to the hohqmesh package. The first argument is the version name as it will appear in the spack package manager. Use the <code>tag</code> argument to specify the name of the tag as it appears in the HOHQMesh repository. As an example, a new version line for <code>v1.0.1</code> is shown below.    <pre><code>version('v1.0.1', tag='v1.0.1')\n</code></pre></p> </li> <li> <p>(Optional) If you would like to be noted as a maintainer, add your GitHub handle to the maintainers list. Maintainers will be notified if Spack users experience issues installing HOHQMesh and when modifications are being made to the HOHQMesh package in Spack.    <pre><code>maintainers = ['schoonovernumerics','your-github-handle']\n</code></pre></p> </li> <li> <p>When you are finished editing, save the package file. You can verify the new version is registered in your local repository by obtaining a <code>spec</code> for HOHQMesh at the new version you've added.    <pre><code>spack spec hohqmesh@v1.0.1\n</code></pre></p> </li> <li> <p>Test to make sure the installation works    <pre><code>spack install hohqmesh@v1.0.1\n</code></pre></p> </li> <li> <p>Run the <code>spack style</code> command to ensure that you are meeting Spack's style requirements.</p> </li> <li> <p>When ready, commit your changes and push them to your GitHub repository.</p> </li> <li> <p>Open a Pull Request against <code>github.com/spack/spack</code> to merge your changes with the <code>spack/spack/develop</code> branch.</p> </li> </ol>"},{"location":"images/","title":"Notes on figures","text":"<p>Command for creating small Trixi: <pre><code>convert TrixiInside.png -resize 64x64 TrixiInside_small.png\n</code></pre></p> <p>Command for turning background transparent: <pre><code>convert TrixiInside_small.png -fill 'transparent' -fuzz 5% -draw 'color 0,0 floodfill' TrixiInside_small_transparent.png\n</code></pre></p> <p>Command for turning a single color completely transparent: <pre><code>convert TrixiInside.png -fuzz 5% -transparent '#52586E' TrixiInside_transparent.png\n</code></pre></p>"}]}