# Three Dimensional Hexahedral Meshes
HOHQMesh can also generate 3D hexahedral meshes by extruding or sweeping a two dimensional mesh. 

To tell the mesher that you want a hex mesh, you add an algorithm block to the *CONTROL\_INPUT* block for how the 3D extrusion will be done. Currently there are three: 

* Simple extrusion, 
* Simple rotation, and 
* Sweeping.

## Simple Extrusion<a name="Extrusion"></a>
	   
![HalfCircleExtruded](https://user-images.githubusercontent.com/3637659/121807827-18303b80-cc56-11eb-855a-891037168827.png)
<p align = "center"> Fig. 16. Simple Extrusion of a semi-circular quadrilateral mesh</p>

The first hex-meshing algorithm is the *SIMPLE\_EXTRUSION* algorithm.

    \begin{SIMPLE_EXTRUSION}
		 direction          = 3
		 height             = 8.0
		 subdivisions       = 8
		 start surface name = bottom
		 end surface name   = top
	 \end{SIMPLE_EXTRUSION}

The direction (where *x* = 1, *y* = 2, z = *3*) says which direction the extrusion is done. Note that even though the initial 2D mesh is in the x-y plane, the quad mesh is rotated to give a hex mesh extruded in the requested direction. The height tells how far to extrude. A name is given to the bottom and top faces created by the extrusion so that boundary conditions can be attached. Otherwise, the names of the faces are given by the 2D curve names.

## Simple Rotation<a name="Rotation"></a>

![IglooAlt](https://user-images.githubusercontent.com/3637659/121807832-1e261c80-cc56-11eb-8c86-9d2a9e07de00.png)
<p align = "center"> Fig. 17. Simple rotation of the mesh in Fig. 3</p>

The second algorithm is the *SIMPLE\_ROTATION*, which rotates the two dimensional mesh about an  axis

    \begin{SIMPLE_ROTATION}
       direction             = 1
       rotation angle factor = 1.0
       subdivisions          = 8
       start surface name    = bottom
       end surface name      = top
    \end{SIMPLE_EXTRUSION}
   
The rotation andle factor is the fraction of pi over which the quad mesh is rotated. An example is shown below of an original two dimensional mesh  
and its rotation about the x axis (direction = 1) is shown in Fig. 17.

## Sweeping<a name="Sweeping"></a>
![Snake](https://user-images.githubusercontent.com/3637659/121807890-588fb980-cc56-11eb-9698-d3efffafed82.png)
<p align = "center"> Fig. 18. Hex mesh generated by sweeping a circular mesh along a curve</p>

 The most general algorithm for generating hex meshes in HOHQMESH is to sweep a two-dimensional mesh along a prescribed curve, *SWEEP\_ALONG\_CURVE*. To sweep along a curve, one does two things: 
 
1.  Add  a *SWEEP\_ALONG\_CURVE* block to the *CONTOL\_INPUT* block and 
2.  Add the curve along which the sweeping is to be done to the *MODEL* block.
 
There are currently two sweeping algorithms available. The default is a simple rotation algorithm that has no method to counteract twisting of the mesh as it follows the curve. (Think of a roller-coaster that can turn upside down as it follows a curved track.) The default algorithm is exact so will sweep the curve to high order, but will only produce an untwisted mesh if the curve is planar.

The second is a parallel transport algorithm due to Hanson and Ma that keeps arbitrary vector in a particular orientation with respect to its initial direction. The parallel transport approach minimizes the twisting of the hex mesh, but is only second order accurate. [A fourth order algorithm may be implemented in the future.]

To implement sweeping, include a SWEEP_ALONG_CURVE block in the *CONTOL\_INPUT* block:

    \begin{SWEEP_ALONG_CURVE}
	    algorithm                = Hanson (optional)
       subdivisions per segment = 8
       start surface name       = bottom
       end surface name         = top
    \end{SWEEP_ALONG_CURVE}
   
The algorithm keyword is optional. If not present, the sweeping will not include the parallel transport correction. Since the sweep curve can be a chain with slope or curvature singularities, the number of subdivisions per segment is defined. This ensures that a singularity occurs along element boundaries so that accuracy is not lost. 

The curve itself is defined in the MODEL block. 

	\begin{SWEEP_CURVE}
		...
	\end{SWEEP_CURVE}

The *SWEEP\_CURVE* block implicitly defines a *CHAIN*, like the *OUTER\_BOUNDARY* block, and so only needs a list of curves to define the sweep.

## Scaling<a name="Scaling"></a>
![ScaledSigmoid](https://user-images.githubusercontent.com/3637659/121807887-54639c00-cc56-11eb-9474-9d809320af9b.png)
<p align = "center"> Fig. 19. Hex mesh generated by sweeping and scaling along a curve</p>

The mesh can also be scaled in the direction normal to the sweep curve when sweeping is used. 
To scale the mesh, add a

	\begin{SWEEP_SCALE_FACTOR}
		...
	\end{SWEEP_SCALE_FACTOR}

block to the *MODEL*. Like the *SWEEP\_CURVE* and *OUTER\_BOUNDARY* blocks, the *SWEEP\_SCALE\_FACTOR* block implicitly defines a *CHAIN*. You do not need to have the number chain segments match the number in the *SWEEP\_ALONG\_CURVE* block, but it is probably best to not introduce slope or curvature singularities except at element interfaces.

The equation for the scaling is scalar *PARAMETRIC\_EQUATION* (as opposed to a *PARAMETRIC\_EQUATION\_CURVE*). It is defined, for example like this:

        \begin{PARAMETRIC_EQUATION}
           eqn = r(t) = 1.0 + 2.5*t*(1-t)
        \end{PARAMETRIC_EQUATION}
        
## Bottom Topography<a name="Topography"></a>
![Pond](https://user-images.githubusercontent.com/3637659/121807861-40b83580-cc56-11eb-8d97-388924e08dee.png)
<p align = "center"> Fig. 20. Simple Extrusion of a semi-circular mesh with bottom topography</p>

When using the *SIMPLE\_EXTRUSION* algorithm, bottom topography can be added as shown below: 
At this time, the bottom topography is defined only as an equation in a TOPOGRAPHY block, e.g.

        \begin{TOPOGRAPHY}
           eqn = h(x,y) = x^2 + y^2
        \end{TOPOGRAPHY}
        
The height function takes two arguments, which are the physical x-y coordinates, unlike the parametric coordinates that define boundary curves.

Currently the only way to define bottom topography is through an equation as above. However that limitation can be overcome by implementing other bottom topography subclasses.
